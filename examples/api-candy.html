<!-- START SIGMA IMPORTS -->
<script src="../sigma.min.js"></script>
<!-- END SIGMA IMPORTS -->
<script src="../plugins/sigma.layout.forceAtlas2/worker.js"></script>
<script src="../plugins/sigma.layout.forceAtlas2/supervisor.js"></script>
<div id="container">
  <style>
    #webgl {
      top: 0;
      bottom: 50%;
      left: 0;
      right: 50%;
      color: #fff;
      background: #000;
      position: absolute;
    }

    #canvas2 {
      top: 50%;
      bottom: 0;
      left: 0;
      right: 50%;
      color: #000;
      background: #eee;
      position: absolute;
    }

    #canvas1 {
      top: 0;
      bottom: 0;
      left: 50%;
      right: 0;
      color: #000;
      background: #fff;
      position: absolute;
    }

    .label {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1;
      font-family: sans-serif;
    }
  </style>
  <div id="webgl">
    <div class="label">WebGL renderer + Camera 1</div>
  </div>
  <div id="canvas1">
    <div class="label">Canvas renderer + Camera 2</div>
  </div>
  <div id="canvas2">
    <div class="label">Canvas renderer + Camera 1</div>
  </div>
</div>
<script id="example-content">
/**
 * This example spawns three different renderers, two of them sharing
 * their camera. Also, a ForceAtlas2 runs on the graph.
 *
 * It is basically a mashup between some other examples, to show how
 * sigma behaves when instantiated in a weird and heavy configuration.
 */

var i,
    s,
    o,
    N = 100,
    E = 500,
    C = 5,
    d = 0.5,
    cs = [],
    g = {
      nodes: [],
      edges: []
    };

for (i = 0; i < C; i++)
  cs.push({
    id: i,
    nodes: [],
    color: '#' + (
      Math.floor(Math.random() * 16777215).toString(16) + '000000'
    ).substr(0, 6)
  });

for (i = 0; i < N; i++) {
  o = cs[(Math.random() * C) | 0];
  g.nodes.push({
    id: 'n' + i,
    label: 'Node' + i,
    x: Math.cos(2 * i * Math.PI / N),
    y: Math.sin(2 * i * Math.PI / N),
    size: 0.5 + 4.5 * Math.random(),
    color: o.color
  });
  o.nodes.push('n' + i);
}

for (i = 0; i < E; i++) {
  if (Math.random() < 1 - d)
    g.edges.push({
      id: 'e' + i,
      size: 0.5,
      source: 'n' + ((Math.random() * N) | 0),
      target: 'n' + ((Math.random() * N) | 0)
    });
  else {
    o = cs[(Math.random() * C) | 0]
    g.edges.push({
      id: 'e' + i,
      size: 0.5,
      source: o.nodes[(Math.random() * o.nodes.length) | 0],
      target: o.nodes[(Math.random() * o.nodes.length) | 0]
    });
  }
}

s = new sigma({
  graph: g,
  settings: {
    skipErrors: true
  }
});

// Initialize cameras:
s.addCamera('cam1'),
s.addCamera('cam2');

// Initialize the three renderers:
s.addRenderer({
  container: document.getElementById('webgl'),
  type: 'webgl',
  camera: 'cam1',
  settings: {
    defaultLabelColor: '#fff'
  }
});

s.addRenderer({
  container: document.getElementById('canvas2'),
  type: 'canvas',
  camera: 'cam1',
  settings: {
    drawEdges: false
  }
});

s.addRenderer({
  container: document.getElementById('canvas1'),
  type: 'canvas',
  camera: 'cam2'
});

// Start the layout algorithm:
s.startForceAtlas2();
</script>
