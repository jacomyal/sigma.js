<!-- START SIGMA IMPORTS -->
<script src="../build/sigma.umd.js"></script>
<!-- END SIGMA IMPORTS -->
<script src="../build/plugins/sigma.layout.forceAtlas2.js"></script>
<script src="../build/plugins/sigma.layout.forceAtlas2.js"></script>
<div id="container">
  <style>
    #webgl {
      top: 0;
      bottom: 50%;
      left: 0;
      right: 50%;
      color: #fff;
      background: #000;
      position: absolute;
    }

    #canvas2 {
      top: 50%;
      bottom: 0;
      left: 0;
      right: 50%;
      color: #000;
      background: #eee;
      position: absolute;
    }

    #canvas1 {
      top: 0;
      bottom: 0;
      left: 50%;
      right: 0;
      color: #000;
      background: #fff;
      position: absolute;
    }

    .label {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1;
      font-family: sans-serif;
    }
  </style>
  <div id="webgl">
    <div class="label">WebGL renderer + Camera 1</div>
  </div>
  <div id="canvas1">
    <div class="label">Canvas renderer + Camera 2</div>
  </div>
  <div id="canvas2">
    <div class="label">Canvas renderer + Camera 1</div>
  </div>
</div>
<script id="example-content">
  /**
   * This example spawns three different renderers, two of them sharing
   * their camera. Also, a ForceAtlas2 runs on the graph.
   *
   * It is basically a mashup between some other examples, to show how
   * sigma behaves when instantiated in a weird and heavy configuration.
   */

  var i,
    s,
    o,
    N = 100,
    E = 500,
    C = 5,
    d = 0.5,
    cs = [],
    g = {
      nodes: [],
      edges: []
    };

  for (i = 0; i < C; i++)
    cs.push({
      id: i,
      nodes: [],
      color:
        "#" +
        (Math.floor(Math.random() * 16777215).toString(16) + "000000").substr(
          0,
          6
        )
    });

  for (i = 0; i < N; i++) {
    o = cs[(Math.random() * C) | 0];
    g.nodes.push({
      id: "n" + i,
      label: "Node" + i,
      x: Math.cos((2 * i * Math.PI) / N),
      y: Math.sin((2 * i * Math.PI) / N),
      size: 0.5 + 4.5 * Math.random(),
      color: o.color
    });
    o.nodes.push("n" + i);
  }

  for (i = 0; i < E; i++) {
    if (Math.random() < 1 - d)
      g.edges.push({
        id: "e" + i,
        size: 0.5,
        source: "n" + ((Math.random() * N) | 0),
        target: "n" + ((Math.random() * N) | 0)
      });
    else {
      o = cs[(Math.random() * C) | 0];
      g.edges.push({
        id: "e" + i,
        size: 0.5,
        source: o.nodes[(Math.random() * o.nodes.length) | 0],
        target: o.nodes[(Math.random() * o.nodes.length) | 0]
      });
    }
  }

  s = new sigma({
    graph: g,
    settings: {
      skipErrors: true
    }
  });

  // Initialize cameras:
  s.addCamera("cam1"), s.addCamera("cam2");

  // Initialize the three renderers:
  s.addRenderer({
    container: document.getElementById("webgl"),
    type: "webgl",
    camera: "cam1",
    settings: {
      defaultLabelColor: "#fff"
    }
  });

  s.addRenderer({
    container: document.getElementById("canvas2"),
    type: "canvas",
    camera: "cam1",
    settings: {
      drawEdges: false
    }
  });

  s.addRenderer({
    container: document.getElementById("canvas1"),
    type: "canvas",
    camera: "cam2"
  });

  // Start the layout algorithm:
  s.startForceAtlas2();
</script>
