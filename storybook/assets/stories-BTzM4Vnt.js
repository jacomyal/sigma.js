import{G as Qt,S as Kt,w as Wt}from"./sigma-BsJT_GRv.js";import{f as Ct}from"./index-BUEWZHga.js";import{F as Yt}from"./worker-B6sB0a3K.js";import{c as rt,a as Zt}from"./_commonjsHelpers-C4iS2aBk.js";import{r as en}from"./___vite-browser-external_commonjs-proxy-BqV5D26a.js";import"./getters-CXJ0gpj8.js";var pe={},ge,at;function Ye(){return at||(at=1,ge=class Pt{constructor(i,g=new Map,h=0){this.prefix=i,this._existing=g,this.counter=h}clone(){const{prefix:i,_existing:g,counter:h}=this;return new Pt(i,new Map(g),h)}getId(i){const g=i&&this._existing.get(i);if(g)return g;const h=this.prefix+this.counter;return this.counter++,i&&this._existing.set(i,h),h}hasId(i){return this._existing.has(i)}getOldIds(){return[...this._existing.keys()]}}),ge}var ye={},it;function tn(){return it||(it=1,function(m,i){if(m.setImmediate)return;var g=1,h={},A=!1,r=m.document,t;function n(k){typeof k!="function"&&(k=new Function(""+k));for(var f=new Array(arguments.length-1),e=0;e<f.length;e++)f[e]=arguments[e+1];var a={callback:k,args:f};return h[g]=a,t(g),g++}function s(k){delete h[k]}function v(k){var f=k.callback,e=k.args;switch(e.length){case 0:f();break;case 1:f(e[0]);break;case 2:f(e[0],e[1]);break;case 3:f(e[0],e[1],e[2]);break;default:f.apply(i,e);break}}function x(k){if(A)setTimeout(x,0,k);else{var f=h[k];if(f){A=!0;try{v(f)}finally{s(k),A=!1}}}}function D(){t=function(k){process.nextTick(function(){x(k)})}}function u(){if(m.postMessage&&!m.importScripts){var k=!0,f=m.onmessage;return m.onmessage=function(){k=!1},m.postMessage("","*"),m.onmessage=f,k}}function l(){var k="setImmediate$"+Math.random()+"$",f=function(e){e.source===m&&typeof e.data=="string"&&e.data.indexOf(k)===0&&x(+e.data.slice(k.length))};m.addEventListener?m.addEventListener("message",f,!1):m.attachEvent("onmessage",f),t=function(e){m.postMessage(k+e,"*")}}function w(){var k=new MessageChannel;k.port1.onmessage=function(f){var e=f.data;x(e)},t=function(f){k.port2.postMessage(f)}}function N(){var k=r.documentElement;t=function(f){var e=r.createElement("script");e.onreadystatechange=function(){x(f),e.onreadystatechange=null,k.removeChild(e),e=null},k.appendChild(e)}}function L(){t=function(k){setTimeout(x,0,k)}}var H=Object.getPrototypeOf&&Object.getPrototypeOf(m);H=H&&H.setTimeout?H:m,{}.toString.call(m.process)==="[object process]"?D():u()?l():m.MessageChannel?w():r&&"onreadystatechange"in r.createElement("script")?N():L(),H.setImmediate=n,H.clearImmediate=s}(typeof self>"u"?typeof rt>"u"?ye:rt:self)),ye}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var me,st;function ue(){if(st)return me;st=1,tn();const m=self.crypto||self.msCrypto;return me=class{constructor(g){if(!(m&&m.subtle))throw new Error("crypto.subtle not found.");if(g==="sha256")this.algorithm={name:"SHA-256"};else if(g==="sha1")this.algorithm={name:"SHA-1"};else throw new Error(`Unsupported algorithm "${g}".`);this._content=""}update(g){this._content+=g}async digest(){const g=new TextEncoder().encode(this._content),h=new Uint8Array(await m.subtle.digest(this.algorithm,g));let A="";for(let r=0;r<h.length;++r)A+=h[r].toString(16).padStart(2,"0");return A}},me}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var ve,ot;function Gt(){return ot||(ot=1,ve=class{constructor(i){this.current=i.sort(),this.done=!1,this.dir=new Map;for(let g=0;g<i.length;++g)this.dir.set(i[g],!0)}hasNext(){return!this.done}next(){const{current:i,dir:g}=this,h=i.slice();let A=null,r=0;const t=i.length;for(let n=0;n<t;++n){const s=i[n],v=g.get(s);(A===null||s>A)&&(v&&n>0&&s>i[n-1]||!v&&n<t-1&&s>i[n+1])&&(A=s,r=n)}if(A===null)this.done=!0;else{const n=g.get(A)?r-1:r+1;i[r]=i[n],i[n]=A;for(const s of i)s>A&&g.set(s,!g.get(s))}return h}}),ve}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var be,lt;function Ze(){if(lt)return be;lt=1;const i="http://www.w3.org/1999/02/22-rdf-syntax-ns#"+"langString",g="http://www.w3.org/2001/XMLSchema#string",h="NamedNode",A="BlankNode",r="Literal",t="DefaultGraph",n={};(()=>{const l="(?:<([^:]+:[^>]*)>)",N="A-Za-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�"+"_",L=N+"0-9-·̀-ͯ‿-⁀",k="(_:(?:["+N+"0-9])(?:(?:["+L+".])*(?:["+L+"]))?)",f='"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"',e="(?:\\^\\^"+l+")",c="(?:"+f+"(?:"+e+"|"+"(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))"+")?)",S="[ \\t]+",d="[ \\t]*",E="(?:"+l+"|"+k+")"+S,b=l+S,F="(?:"+l+"|"+k+"|"+c+")"+d,M="(?:\\.|(?:(?:"+l+"|"+k+")"+d+"\\.))";n.eoln=/(?:\r\n)|(?:\n)|(?:\r)/g,n.empty=new RegExp("^"+d+"$"),n.quad=new RegExp("^"+d+E+b+F+M+d+"$")})(),be=class ce{static parse(w){const N=[],L={},H=w.split(n.eoln);let k=0;for(const f of H){if(k++,n.empty.test(f))continue;const e=f.match(n.quad);if(e===null)throw new Error("N-Quads parse error on line "+k+".");const a={subject:null,predicate:null,object:null,graph:null};if(e[1]!==void 0?a.subject={termType:h,value:e[1]}:a.subject={termType:A,value:e[2]},a.predicate={termType:h,value:e[3]},e[4]!==void 0?a.object={termType:h,value:e[4]}:e[5]!==void 0?a.object={termType:A,value:e[5]}:(a.object={termType:r,value:void 0,datatype:{termType:h}},e[7]!==void 0?a.object.datatype.value=e[7]:e[8]!==void 0?(a.object.datatype.value=i,a.object.language=e[8]):a.object.datatype.value=g,a.object.value=u(e[6])),e[9]!==void 0?a.graph={termType:h,value:e[9]}:e[10]!==void 0?a.graph={termType:A,value:e[10]}:a.graph={termType:t,value:""},!(a.graph.value in L))L[a.graph.value]=[a],N.push(a);else{let c=!0;const S=L[a.graph.value];for(const d of S)if(s(d,a)){c=!1;break}c&&(S.push(a),N.push(a))}}return N}static serialize(w){Array.isArray(w)||(w=ce.legacyDatasetToQuads(w));const N=[];for(const L of w)N.push(ce.serializeQuad(L));return N.sort().join("")}static serializeQuadComponents(w,N,L,H){let k="";return w.termType===h?k+=`<${w.value}>`:k+=`${w.value}`,k+=` <${N.value}> `,L.termType===h?k+=`<${L.value}>`:L.termType===A?k+=L.value:(k+=`"${x(L.value)}"`,L.datatype.value===i?L.language&&(k+=`@${L.language}`):L.datatype.value!==g&&(k+=`^^<${L.datatype.value}>`)),H.termType===h?k+=` <${H.value}>`:H.termType===A&&(k+=` ${H.value}`),k+=` .
`,k}static serializeQuad(w){return ce.serializeQuadComponents(w.subject,w.predicate,w.object,w.graph)}static legacyDatasetToQuads(w){const N=[],L={"blank node":A,IRI:h,literal:r};for(const H in w)w[H].forEach(f=>{const e={};for(const a in f){const c=f[a],S={termType:L[c.type],value:c.value};S.termType===r&&(S.datatype={termType:h},"datatype"in c&&(S.datatype.value=c.datatype),"language"in c?("datatype"in c||(S.datatype.value=i),S.language=c.language):"datatype"in c||(S.datatype.value=g)),e[a]=S}H==="@default"?e.graph={termType:t,value:""}:e.graph={termType:H.startsWith("_:")?A:h,value:H},N.push(e)});return N}};function s(l,w){return!(l.subject.termType===w.subject.termType&&l.object.termType===w.object.termType)||!(l.subject.value===w.subject.value&&l.predicate.value===w.predicate.value&&l.object.value===w.object.value)?!1:l.object.termType!==r?!0:l.object.datatype.termType===w.object.datatype.termType&&l.object.language===w.object.language&&l.object.datatype.value===w.object.datatype.value}const v=/["\\\n\r]/g;function x(l){return l.replace(v,function(w){switch(w){case'"':return'\\"';case"\\":return"\\\\";case`
`:return"\\n";case"\r":return"\\r"}})}const D=/(?:\\([tbnrf"'\\]))|(?:\\u([0-9A-Fa-f]{4}))|(?:\\U([0-9A-Fa-f]{8}))/g;function u(l){return l.replace(D,function(w,N,L,H){if(N)switch(N){case"t":return"	";case"b":return"\b";case"n":return`
`;case"r":return"\r";case"f":return"\f";case'"':return'"';case"'":return"'";case"\\":return"\\"}if(L)return String.fromCharCode(parseInt(L,16));if(H)throw new Error("Unsupported U escape")})}return be}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var we,ct;function Vt(){if(ct)return we;ct=1;const m=Ye(),i=ue(),g=Gt(),h=Ze();we=class{constructor({createMessageDigest:t=()=>new i("sha256"),canonicalIdMap:n=new Map,maxDeepIterations:s=1/0}={}){this.name="URDNA2015",this.blankNodeInfo=new Map,this.canonicalIssuer=new m("_:c14n",n),this.createMessageDigest=t,this.maxDeepIterations=s,this.quads=null,this.deepIterations=null}async main(t){this.deepIterations=new Map,this.quads=t;for(const l of t)this._addBlankNodeQuadInfo({quad:l,component:l.subject}),this._addBlankNodeQuadInfo({quad:l,component:l.object}),this._addBlankNodeQuadInfo({quad:l,component:l.graph});const n=new Map,s=[...this.blankNodeInfo.keys()];let v=0;for(const l of s)++v%100===0&&await this._yield(),await this._hashAndTrackBlankNode({id:l,hashToBlankNodes:n});const x=[...n.keys()].sort(),D=[];for(const l of x){const w=n.get(l);if(w.length>1){D.push(w);continue}const N=w[0];this.canonicalIssuer.getId(N)}for(const l of D){const w=[];for(const N of l){if(this.canonicalIssuer.hasId(N))continue;const L=new m("_:b");L.getId(N);const H=await this.hashNDegreeQuads(N,L);w.push(H)}w.sort(A);for(const N of w){const L=N.issuer.getOldIds();for(const H of L)this.canonicalIssuer.getId(H)}}const u=[];for(const l of this.quads){const w=h.serializeQuadComponents(this._componentWithCanonicalId(l.subject),l.predicate,this._componentWithCanonicalId(l.object),this._componentWithCanonicalId(l.graph));u.push(w)}return u.sort(),u.join("")}async hashFirstDegreeQuads(t){const n=[],s=this.blankNodeInfo.get(t),v=s.quads;for(const D of v){const u={subject:null,predicate:D.predicate,object:null,graph:null};u.subject=this.modifyFirstDegreeComponent(t,D.subject,"subject"),u.object=this.modifyFirstDegreeComponent(t,D.object,"object"),u.graph=this.modifyFirstDegreeComponent(t,D.graph,"graph"),n.push(h.serializeQuad(u))}n.sort();const x=this.createMessageDigest();for(const D of n)x.update(D);return s.hash=await x.digest(),s.hash}async hashRelatedBlankNode(t,n,s,v){let x;this.canonicalIssuer.hasId(t)?x=this.canonicalIssuer.getId(t):s.hasId(t)?x=s.getId(t):x=this.blankNodeInfo.get(t).hash;const D=this.createMessageDigest();return D.update(v),v!=="g"&&D.update(this.getRelatedPredicate(n)),D.update(x),D.digest()}async hashNDegreeQuads(t,n){const s=this.deepIterations.get(t)||0;if(s>this.maxDeepIterations)throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);this.deepIterations.set(t,s+1);const v=this.createMessageDigest(),x=await this.createHashToRelated(t,n),D=[...x.keys()].sort();for(const u of D){v.update(u);let l="",w;const N=new g(x.get(u));let L=0;for(;N.hasNext();){const H=N.next();++L%3===0&&await this._yield();let k=n.clone(),f="";const e=[];let a=!1;for(const c of H)if(this.canonicalIssuer.hasId(c)?f+=this.canonicalIssuer.getId(c):(k.hasId(c)||e.push(c),f+=k.getId(c)),l.length!==0&&f>l){a=!0;break}if(!a){for(const c of e){const S=await this.hashNDegreeQuads(c,k);if(f+=k.getId(c),f+=`<${S.hash}>`,k=S.issuer,l.length!==0&&f>l){a=!0;break}}a||(l.length===0||f<l)&&(l=f,w=k)}}v.update(l),n=w}return{hash:await v.digest(),issuer:n}}modifyFirstDegreeComponent(t,n){return n.termType!=="BlankNode"?n:{termType:"BlankNode",value:n.value===t?"_:a":"_:z"}}getRelatedPredicate(t){return`<${t.predicate.value}>`}async createHashToRelated(t,n){const s=new Map,v=this.blankNodeInfo.get(t).quads;let x=0;for(const D of v)++x%100===0&&await this._yield(),await Promise.all([this._addRelatedBlankNodeHash({quad:D,component:D.subject,position:"s",id:t,issuer:n,hashToRelated:s}),this._addRelatedBlankNodeHash({quad:D,component:D.object,position:"o",id:t,issuer:n,hashToRelated:s}),this._addRelatedBlankNodeHash({quad:D,component:D.graph,position:"g",id:t,issuer:n,hashToRelated:s})]);return s}async _hashAndTrackBlankNode({id:t,hashToBlankNodes:n}){const s=await this.hashFirstDegreeQuads(t),v=n.get(s);v?v.push(t):n.set(s,[t])}_addBlankNodeQuadInfo({quad:t,component:n}){if(n.termType!=="BlankNode")return;const s=n.value,v=this.blankNodeInfo.get(s);v?v.quads.add(t):this.blankNodeInfo.set(s,{quads:new Set([t]),hash:null})}async _addRelatedBlankNodeHash({quad:t,component:n,position:s,id:v,issuer:x,hashToRelated:D}){if(!(n.termType==="BlankNode"&&n.value!==v))return;const u=n.value,l=await this.hashRelatedBlankNode(u,t,x,s),w=D.get(l);w?w.push(u):D.set(l,[u])}_componentWithCanonicalId(t){return t.termType==="BlankNode"&&!t.value.startsWith(this.canonicalIssuer.prefix)?{termType:"BlankNode",value:this.canonicalIssuer.getId(t.value)}:t}async _yield(){return new Promise(t=>setImmediate(t))}};function A(r,t){return r.hash<t.hash?-1:r.hash>t.hash?1:0}return we}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var Ie,ut;function nn(){if(ut)return Ie;ut=1;const m=ue(),i=Vt();return Ie=class extends i{constructor(){super(),this.name="URGNA2012",this.createMessageDigest=()=>new m("sha1")}modifyFirstDegreeComponent(h,A,r){return A.termType!=="BlankNode"?A:r==="graph"?{termType:"BlankNode",value:"_:g"}:{termType:"BlankNode",value:A.value===h?"_:a":"_:z"}}getRelatedPredicate(h){return h.predicate.value}async createHashToRelated(h,A){const r=new Map,t=this.blankNodeInfo.get(h).quads;let n=0;for(const s of t){let v,x;if(s.subject.termType==="BlankNode"&&s.subject.value!==h)x=s.subject.value,v="p";else if(s.object.termType==="BlankNode"&&s.object.value!==h)x=s.object.value,v="r";else continue;++n%100===0&&await this._yield();const D=await this.hashRelatedBlankNode(x,s,A,v),u=r.get(D);u?u.push(x):r.set(D,[x])}return r}},Ie}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var xe,dt;function $t(){if(dt)return xe;dt=1;const m=Ye(),i=ue(),g=Gt(),h=Ze();xe=class{constructor({createMessageDigest:t=()=>new i("sha256"),canonicalIdMap:n=new Map,maxDeepIterations:s=1/0}={}){this.name="URDNA2015",this.blankNodeInfo=new Map,this.canonicalIssuer=new m("_:c14n",n),this.createMessageDigest=t,this.maxDeepIterations=s,this.quads=null,this.deepIterations=null}main(t){this.deepIterations=new Map,this.quads=t;for(const u of t)this._addBlankNodeQuadInfo({quad:u,component:u.subject}),this._addBlankNodeQuadInfo({quad:u,component:u.object}),this._addBlankNodeQuadInfo({quad:u,component:u.graph});const n=new Map,s=[...this.blankNodeInfo.keys()];for(const u of s)this._hashAndTrackBlankNode({id:u,hashToBlankNodes:n});const v=[...n.keys()].sort(),x=[];for(const u of v){const l=n.get(u);if(l.length>1){x.push(l);continue}const w=l[0];this.canonicalIssuer.getId(w)}for(const u of x){const l=[];for(const w of u){if(this.canonicalIssuer.hasId(w))continue;const N=new m("_:b");N.getId(w);const L=this.hashNDegreeQuads(w,N);l.push(L)}l.sort(A);for(const w of l){const N=w.issuer.getOldIds();for(const L of N)this.canonicalIssuer.getId(L)}}const D=[];for(const u of this.quads){const l=h.serializeQuadComponents(this._componentWithCanonicalId({component:u.subject}),u.predicate,this._componentWithCanonicalId({component:u.object}),this._componentWithCanonicalId({component:u.graph}));D.push(l)}return D.sort(),D.join("")}hashFirstDegreeQuads(t){const n=[],s=this.blankNodeInfo.get(t),v=s.quads;for(const D of v){const u={subject:null,predicate:D.predicate,object:null,graph:null};u.subject=this.modifyFirstDegreeComponent(t,D.subject,"subject"),u.object=this.modifyFirstDegreeComponent(t,D.object,"object"),u.graph=this.modifyFirstDegreeComponent(t,D.graph,"graph"),n.push(h.serializeQuad(u))}n.sort();const x=this.createMessageDigest();for(const D of n)x.update(D);return s.hash=x.digest(),s.hash}hashRelatedBlankNode(t,n,s,v){let x;this.canonicalIssuer.hasId(t)?x=this.canonicalIssuer.getId(t):s.hasId(t)?x=s.getId(t):x=this.blankNodeInfo.get(t).hash;const D=this.createMessageDigest();return D.update(v),v!=="g"&&D.update(this.getRelatedPredicate(n)),D.update(x),D.digest()}hashNDegreeQuads(t,n){const s=this.deepIterations.get(t)||0;if(s>this.maxDeepIterations)throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);this.deepIterations.set(t,s+1);const v=this.createMessageDigest(),x=this.createHashToRelated(t,n),D=[...x.keys()].sort();for(const u of D){v.update(u);let l="",w;const N=new g(x.get(u));for(;N.hasNext();){const L=N.next();let H=n.clone(),k="";const f=[];let e=!1;for(const a of L)if(this.canonicalIssuer.hasId(a)?k+=this.canonicalIssuer.getId(a):(H.hasId(a)||f.push(a),k+=H.getId(a)),l.length!==0&&k>l){e=!0;break}if(!e){for(const a of f){const c=this.hashNDegreeQuads(a,H);if(k+=H.getId(a),k+=`<${c.hash}>`,H=c.issuer,l.length!==0&&k>l){e=!0;break}}e||(l.length===0||k<l)&&(l=k,w=H)}}v.update(l),n=w}return{hash:v.digest(),issuer:n}}modifyFirstDegreeComponent(t,n){return n.termType!=="BlankNode"?n:{termType:"BlankNode",value:n.value===t?"_:a":"_:z"}}getRelatedPredicate(t){return`<${t.predicate.value}>`}createHashToRelated(t,n){const s=new Map,v=this.blankNodeInfo.get(t).quads;for(const x of v)this._addRelatedBlankNodeHash({quad:x,component:x.subject,position:"s",id:t,issuer:n,hashToRelated:s}),this._addRelatedBlankNodeHash({quad:x,component:x.object,position:"o",id:t,issuer:n,hashToRelated:s}),this._addRelatedBlankNodeHash({quad:x,component:x.graph,position:"g",id:t,issuer:n,hashToRelated:s});return s}_hashAndTrackBlankNode({id:t,hashToBlankNodes:n}){const s=this.hashFirstDegreeQuads(t),v=n.get(s);v?v.push(t):n.set(s,[t])}_addBlankNodeQuadInfo({quad:t,component:n}){if(n.termType!=="BlankNode")return;const s=n.value,v=this.blankNodeInfo.get(s);v?v.quads.add(t):this.blankNodeInfo.set(s,{quads:new Set([t]),hash:null})}_addRelatedBlankNodeHash({quad:t,component:n,position:s,id:v,issuer:x,hashToRelated:D}){if(!(n.termType==="BlankNode"&&n.value!==v))return;const u=n.value,l=this.hashRelatedBlankNode(u,t,x,s),w=D.get(l);w?w.push(u):D.set(l,[u])}_componentWithCanonicalId({component:t}){return t.termType==="BlankNode"&&!t.value.startsWith(this.canonicalIssuer.prefix)?{termType:"BlankNode",value:this.canonicalIssuer.getId(t.value)}:t}};function A(r,t){return r.hash<t.hash?-1:r.hash>t.hash?1:0}return xe}/*!
 * Copyright (c) 2016-2021 Digital Bazaar, Inc. All rights reserved.
 */var Ee,ft;function rn(){if(ft)return Ee;ft=1;const m=ue(),i=$t();return Ee=class extends i{constructor(){super(),this.name="URGNA2012",this.createMessageDigest=()=>new m("sha1")}modifyFirstDegreeComponent(h,A,r){return A.termType!=="BlankNode"?A:r==="graph"?{termType:"BlankNode",value:"_:g"}:{termType:"BlankNode",value:A.value===h?"_:a":"_:z"}}getRelatedPredicate(h){return h.predicate.value}createHashToRelated(h,A){const r=new Map,t=this.blankNodeInfo.get(h).quads;for(const n of t){let s,v;if(n.subject.termType==="BlankNode"&&n.subject.value!==h)v=n.subject.value,s="p";else if(n.object.termType==="BlankNode"&&n.object.value!==h)v=n.object.value,s="r";else continue;const x=this.hashRelatedBlankNode(v,n,A,s),D=r.get(x);D?D.push(v):r.set(x,[v])}return r}},Ee}var ht;function an(){return ht||(ht=1,function(m){const i=Vt(),g=nn(),h=$t(),A=rn();let r;try{r=en}catch{}function t(n){return Array.isArray(n)?n:m.NQuads.legacyDatasetToQuads(n)}m.NQuads=Ze(),m.IdentifierIssuer=Ye(),m._rdfCanonizeNative=function(n){return n&&(r=n),r},m.canonize=async function(n,s){const v=t(n);if(s.useNative){if(!r)throw new Error("rdf-canonize-native not available");if(s.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "useNative".');return new Promise((x,D)=>r.canonize(v,s,(u,l)=>u?D(u):x(l)))}if(s.algorithm==="URDNA2015")return new i(s).main(v);if(s.algorithm==="URGNA2012"){if(s.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');return new g(s).main(v)}throw"algorithm"in s?new Error("Invalid RDF Dataset Canonicalization algorithm: "+s.algorithm):new Error("No RDF Dataset Canonicalization algorithm specified.")},m._canonizeSync=function(n,s){const v=t(n);if(s.useNative){if(!r)throw new Error("rdf-canonize-native not available");if(s.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "useNative".');return r.canonizeSync(v,s)}if(s.algorithm==="URDNA2015")return new h(s).main(v);if(s.algorithm==="URGNA2012"){if(s.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');return new A(s).main(v)}throw"algorithm"in s?new Error("Invalid RDF Dataset Canonicalization algorithm: "+s.algorithm):new Error("No RDF Dataset Canonicalization algorithm specified.")}}(pe)),pe}var Ne,pt;function et(){return pt||(pt=1,Ne=an()),Ne}var je,gt;function ee(){if(gt)return je;gt=1;const m={};return je=m,m.isArray=Array.isArray,m.isBoolean=i=>typeof i=="boolean"||Object.prototype.toString.call(i)==="[object Boolean]",m.isDouble=i=>m.isNumber(i)&&(String(i).indexOf(".")!==-1||Math.abs(i)>=1e21),m.isEmptyObject=i=>m.isObject(i)&&Object.keys(i).length===0,m.isNumber=i=>typeof i=="number"||Object.prototype.toString.call(i)==="[object Number]",m.isNumeric=i=>!isNaN(parseFloat(i))&&isFinite(i),m.isObject=i=>Object.prototype.toString.call(i)==="[object Object]",m.isString=i=>typeof i=="string"||Object.prototype.toString.call(i)==="[object String]",m.isUndefined=i=>typeof i>"u",je}var Se,yt;function re(){if(yt)return Se;yt=1;const m=ee(),i={};return Se=i,i.isSubject=g=>m.isObject(g)&&!("@value"in g||"@set"in g||"@list"in g)?Object.keys(g).length>1||!("@id"in g):!1,i.isSubjectReference=g=>m.isObject(g)&&Object.keys(g).length===1&&"@id"in g,i.isValue=g=>m.isObject(g)&&"@value"in g,i.isList=g=>m.isObject(g)&&"@list"in g,i.isGraph=g=>m.isObject(g)&&"@graph"in g&&Object.keys(g).filter(h=>h!=="@id"&&h!=="@index").length===1,i.isSimpleGraph=g=>i.isGraph(g)&&!("@id"in g),i.isBlankNode=g=>{if(m.isObject(g)){if("@id"in g){const h=g["@id"];return!m.isString(h)||h.indexOf("_:")===0}return Object.keys(g).length===0||!("@value"in g||"@set"in g||"@list"in g)}return!1},Se}var _e,mt;function ne(){return mt||(mt=1,_e=class extends Error{constructor(i="An unspecified JSON-LD error occurred.",g="jsonld.Error",h={}){super(i),this.name=g,this.message=i,this.details=h}}),_e}var Re,vt;function te(){if(vt)return Re;vt=1;const m=re(),i=ee(),g=et().IdentifierIssuer,h=ne(),A=/^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/,r=/(?:<[^>]*?>|"[^"]*?"|[^,])+/g,t=/\s*<([^>]*?)>\s*(?:;\s*(.*))?/,n=/(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g,s=/^@[a-zA-Z]+$/,v={headers:{accept:"application/ld+json, application/json"}},x={};Re=x,x.IdentifierIssuer=g,x.REGEX_BCP47=A,x.REGEX_KEYWORD=s,x.clone=function(u){if(u&&typeof u=="object"){let l;if(i.isArray(u)){l=[];for(let w=0;w<u.length;++w)l[w]=x.clone(u[w])}else if(u instanceof Map){l=new Map;for(const[w,N]of u)l.set(w,x.clone(N))}else if(u instanceof Set){l=new Set;for(const w of u)l.add(x.clone(w))}else if(i.isObject(u)){l={};for(const w in u)l[w]=x.clone(u[w])}else l=u.toString();return l}return u},x.asArray=function(u){return Array.isArray(u)?u:[u]},x.buildHeaders=(u={})=>{if(Object.keys(u).some(w=>w.toLowerCase()==="accept"))throw new RangeError('Accept header may not be specified; only "'+v.headers.accept+'" is supported.');return Object.assign({Accept:v.headers.accept},u)},x.parseLinkHeader=u=>{const l={},w=u.match(r);for(let N=0;N<w.length;++N){let L=w[N].match(t);if(!L)continue;const H={target:L[1]},k=L[2];for(;L=n.exec(k);)H[L[1]]=L[2]===void 0?L[3]:L[2];const f=H.rel||"";Array.isArray(l[f])?l[f].push(H):l.hasOwnProperty(f)?l[f]=[l[f],H]:l[f]=H}return l},x.validateTypeValue=(u,l)=>{if(!i.isString(u)&&!(i.isArray(u)&&u.every(w=>i.isString(w)))){if(l&&i.isObject(u))switch(Object.keys(u).length){case 0:return;case 1:if("@default"in u&&x.asArray(u["@default"]).every(w=>i.isString(w)))return}throw new h('Invalid JSON-LD syntax; "@type" value must a string, an array of strings, an empty object, or a default object.',"jsonld.SyntaxError",{code:"invalid type value",value:u})}},x.hasProperty=(u,l)=>{if(u.hasOwnProperty(l)){const w=u[l];return!i.isArray(w)||w.length>0}return!1},x.hasValue=(u,l,w)=>{if(x.hasProperty(u,l)){let N=u[l];const L=m.isList(N);if(i.isArray(N)||L){L&&(N=N["@list"]);for(let H=0;H<N.length;++H)if(x.compareValues(w,N[H]))return!0}else if(!i.isArray(w))return x.compareValues(w,N)}return!1},x.addValue=(u,l,w,N)=>{if(N=N||{},"propertyIsArray"in N||(N.propertyIsArray=!1),"valueIsArray"in N||(N.valueIsArray=!1),"allowDuplicate"in N||(N.allowDuplicate=!0),"prependValue"in N||(N.prependValue=!1),N.valueIsArray)u[l]=w;else if(i.isArray(w)){w.length===0&&N.propertyIsArray&&!u.hasOwnProperty(l)&&(u[l]=[]),N.prependValue&&(w=w.concat(u[l]),u[l]=[]);for(let L=0;L<w.length;++L)x.addValue(u,l,w[L],N)}else if(u.hasOwnProperty(l)){const L=!N.allowDuplicate&&x.hasValue(u,l,w);!i.isArray(u[l])&&(!L||N.propertyIsArray)&&(u[l]=[u[l]]),L||(N.prependValue?u[l].unshift(w):u[l].push(w))}else u[l]=N.propertyIsArray?[w]:w},x.getValues=(u,l)=>[].concat(u[l]||[]),x.removeProperty=(u,l)=>{delete u[l]},x.removeValue=(u,l,w,N)=>{N=N||{},"propertyIsArray"in N||(N.propertyIsArray=!1);const L=x.getValues(u,l).filter(H=>!x.compareValues(H,w));L.length===0?x.removeProperty(u,l):L.length===1&&!N.propertyIsArray?u[l]=L[0]:u[l]=L},x.relabelBlankNodes=(u,l)=>{l=l||{};const w=l.issuer||new g("_:b");return D(w,u)},x.compareValues=(u,l)=>u===l||m.isValue(u)&&m.isValue(l)&&u["@value"]===l["@value"]&&u["@type"]===l["@type"]&&u["@language"]===l["@language"]&&u["@index"]===l["@index"]?!0:i.isObject(u)&&"@id"in u&&i.isObject(l)&&"@id"in l?u["@id"]===l["@id"]:!1,x.compareShortestLeast=(u,l)=>u.length<l.length?-1:l.length<u.length?1:u===l?0:u<l?-1:1;function D(u,l){if(i.isArray(l))for(let w=0;w<l.length;++w)l[w]=D(u,l[w]);else if(m.isList(l))l["@list"]=D(u,l["@list"]);else if(i.isObject(l)){m.isBlankNode(l)&&(l["@id"]=u.getId(l["@id"]));const w=Object.keys(l).sort();for(let N=0;N<w.length;++N){const L=w[N];L!=="@id"&&(l[L]=D(u,l[L]))}}return l}return Re}var De,bt;function tt(){if(bt)return De;bt=1;const m="http://www.w3.org/1999/02/22-rdf-syntax-ns#",i="http://www.w3.org/2001/XMLSchema#";return De={LINK_HEADER_REL:"http://www.w3.org/ns/json-ld#context",LINK_HEADER_CONTEXT:"http://www.w3.org/ns/json-ld#context",RDF:m,RDF_LIST:m+"List",RDF_FIRST:m+"first",RDF_REST:m+"rest",RDF_NIL:m+"nil",RDF_TYPE:m+"type",RDF_PLAIN_LITERAL:m+"PlainLiteral",RDF_XML_LITERAL:m+"XMLLiteral",RDF_JSON_LITERAL:m+"JSON",RDF_OBJECT:m+"object",RDF_LANGSTRING:m+"langString",XSD:i,XSD_BOOLEAN:i+"boolean",XSD_DOUBLE:i+"double",XSD_INTEGER:i+"integer",XSD_STRING:i+"string"},De}var Le,wt;function zt(){return wt||(wt=1,Le=class{constructor(){this._requests={}}wrapLoader(i){const g=this;return g._loader=i,function(){return g.add.apply(g,arguments)}}async add(i){let g=this._requests[i];if(g)return Promise.resolve(g);g=this._requests[i]=this._loader(i);try{return await g}finally{delete this._requests[i]}}}),Le}var Oe,It;function ae(){if(It)return Oe;It=1;const m=ee(),i={};Oe=i,i.parsers={simple:{keys:["href","scheme","authority","path","query","fragment"],regex:/^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/},full:{keys:["href","protocol","scheme","authority","auth","user","password","hostname","port","path","directory","file","query","fragment"],regex:/^(([a-zA-Z][a-zA-Z0-9+-.]*):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(?:(((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/}},i.parse=(h,A)=>{const r={},t=i.parsers[A||"full"],n=t.regex.exec(h);let s=t.keys.length;for(;s--;)r[t.keys[s]]=n[s]===void 0?null:n[s];return(r.scheme==="https"&&r.port==="443"||r.scheme==="http"&&r.port==="80")&&(r.href=r.href.replace(":"+r.port,""),r.authority=r.authority.replace(":"+r.port,""),r.port=null),r.normalizedPath=i.removeDotSegments(r.path),r},i.prependBase=(h,A)=>{if(h===null||i.isAbsolute(A))return A;(!h||m.isString(h))&&(h=i.parse(h||""));const r=i.parse(A),t={protocol:h.protocol||""};if(r.authority!==null)t.authority=r.authority,t.path=r.path,t.query=r.query;else if(t.authority=h.authority,r.path==="")t.path=h.path,r.query!==null?t.query=r.query:t.query=h.query;else{if(r.path.indexOf("/")===0)t.path=r.path;else{let s=h.path;s=s.substr(0,s.lastIndexOf("/")+1),(s.length>0||h.authority)&&s.substr(-1)!=="/"&&(s+="/"),s+=r.path,t.path=s}t.query=r.query}r.path!==""&&(t.path=i.removeDotSegments(t.path));let n=t.protocol;return t.authority!==null&&(n+="//"+t.authority),n+=t.path,t.query!==null&&(n+="?"+t.query),r.fragment!==null&&(n+="#"+r.fragment),n===""&&(n="./"),n},i.removeBase=(h,A)=>{if(h===null)return A;(!h||m.isString(h))&&(h=i.parse(h||""));let r="";if(h.href!==""?r+=(h.protocol||"")+"//"+(h.authority||""):A.indexOf("//")&&(r+="//"),A.indexOf(r)!==0)return A;const t=i.parse(A.substr(r.length)),n=h.normalizedPath.split("/"),s=t.normalizedPath.split("/"),v=t.fragment||t.query?0:1;for(;n.length>0&&s.length>v&&n[0]===s[0];)n.shift(),s.shift();let x="";if(n.length>0){n.pop();for(let D=0;D<n.length;++D)x+="../"}return x+=s.join("/"),t.query!==null&&(x+="?"+t.query),t.fragment!==null&&(x+="#"+t.fragment),x===""&&(x="./"),x},i.removeDotSegments=h=>{if(h.length===0)return"";const A=h.split("/"),r=[];for(;A.length>0;){const t=A.shift(),n=A.length===0;if(t==="."){n&&r.push("");continue}if(t===".."){r.pop(),n&&r.push("");continue}r.push(t)}return h[0]==="/"&&r.length>0&&r[0]!==""&&r.unshift(""),r.length===1&&r[0]===""?"/":r.join("/")};const g=/^([A-Za-z][A-Za-z0-9+-.]*|_):[^\s]*$/;return i.isAbsolute=h=>m.isString(h)&&g.test(h),i.isRelative=h=>m.isString(h),Oe}var Ae,xt;function sn(){if(xt)return Ae;xt=1;const{parseLinkHeader:m,buildHeaders:i}=te(),{LINK_HEADER_CONTEXT:g}=tt(),h=ne(),A=zt(),{prependBase:r}=ae(),t=/(^|(\r\n))link:/i;Ae=({secure:s,headers:v={},xhr:x}={headers:{}})=>{return v=i(v),new A().wrapLoader(u);async function u(l){if(l.indexOf("http:")!==0&&l.indexOf("https:")!==0)throw new h('URL could not be dereferenced; only "http" and "https" URLs are supported.',"jsonld.InvalidUrl",{code:"loading document failed",url:l});if(s&&l.indexOf("https")!==0)throw new h(`URL could not be dereferenced; secure mode is enabled and the URL's scheme is not "https".`,"jsonld.InvalidUrl",{code:"loading document failed",url:l});let w;try{w=await n(x,l,v)}catch(f){throw new h("URL could not be dereferenced, an error occurred.","jsonld.LoadDocumentError",{code:"loading document failed",url:l,cause:f})}if(w.status>=400)throw new h("URL could not be dereferenced: "+w.statusText,"jsonld.LoadDocumentError",{code:"loading document failed",url:l,httpStatusCode:w.status});let N={contextUrl:null,documentUrl:l,document:w.response},L=null;const H=w.getResponseHeader("Content-Type");let k;if(t.test(w.getAllResponseHeaders())&&(k=w.getResponseHeader("Link")),k&&H!=="application/ld+json"){const f=m(k),e=f[g];if(Array.isArray(e))throw new h("URL could not be dereferenced, it has more than one associated HTTP Link Header.","jsonld.InvalidUrl",{code:"multiple context link headers",url:l});e&&(N.contextUrl=e.target),L=f.alternate,L&&L.type=="application/ld+json"&&!(H||"").match(/^application\/(\w*\+)?json$/)&&(N=await u(r(l,L.target)))}return N}};function n(s,v,x){s=s||XMLHttpRequest;const D=new s;return new Promise((u,l)=>{D.onload=()=>u(D),D.onerror=w=>l(w),D.open("GET",v,!0);for(const w in x)D.setRequestHeader(w,x[w]);D.send()})}return Ae}var Te,Et;function on(){if(Et)return Te;Et=1;const m=sn(),i={};return Te=i,i.setupDocumentLoaders=function(g){typeof XMLHttpRequest<"u"&&(g.documentLoaders.xhr=m,g.useDocumentLoader("xhr"))},i.setupGlobals=function(g){typeof globalThis.JsonLdProcessor>"u"&&Object.defineProperty(globalThis,"JsonLdProcessor",{writable:!0,enumerable:!1,configurable:!0,value:g.JsonLdProcessor})},Te}var ke,Nt;function ln(){return Nt||(Nt=1,ke=function(m){m.prototype[Symbol.iterator]=function*(){for(let i=this.head;i;i=i.next)yield i.value}}),ke}var Me,jt;function cn(){if(jt)return Me;jt=1,Me=m,m.Node=A,m.create=m;function m(r){var t=this;if(t instanceof m||(t=new m),t.tail=null,t.head=null,t.length=0,r&&typeof r.forEach=="function")r.forEach(function(v){t.push(v)});else if(arguments.length>0)for(var n=0,s=arguments.length;n<s;n++)t.push(arguments[n]);return t}m.prototype.removeNode=function(r){if(r.list!==this)throw new Error("removing node which does not belong to this list");var t=r.next,n=r.prev;return t&&(t.prev=n),n&&(n.next=t),r===this.head&&(this.head=t),r===this.tail&&(this.tail=n),r.list.length--,r.next=null,r.prev=null,r.list=null,t},m.prototype.unshiftNode=function(r){if(r!==this.head){r.list&&r.list.removeNode(r);var t=this.head;r.list=this,r.next=t,t&&(t.prev=r),this.head=r,this.tail||(this.tail=r),this.length++}},m.prototype.pushNode=function(r){if(r!==this.tail){r.list&&r.list.removeNode(r);var t=this.tail;r.list=this,r.prev=t,t&&(t.next=r),this.tail=r,this.head||(this.head=r),this.length++}},m.prototype.push=function(){for(var r=0,t=arguments.length;r<t;r++)g(this,arguments[r]);return this.length},m.prototype.unshift=function(){for(var r=0,t=arguments.length;r<t;r++)h(this,arguments[r]);return this.length},m.prototype.pop=function(){if(this.tail){var r=this.tail.value;return this.tail=this.tail.prev,this.tail?this.tail.next=null:this.head=null,this.length--,r}},m.prototype.shift=function(){if(this.head){var r=this.head.value;return this.head=this.head.next,this.head?this.head.prev=null:this.tail=null,this.length--,r}},m.prototype.forEach=function(r,t){t=t||this;for(var n=this.head,s=0;n!==null;s++)r.call(t,n.value,s,this),n=n.next},m.prototype.forEachReverse=function(r,t){t=t||this;for(var n=this.tail,s=this.length-1;n!==null;s--)r.call(t,n.value,s,this),n=n.prev},m.prototype.get=function(r){for(var t=0,n=this.head;n!==null&&t<r;t++)n=n.next;if(t===r&&n!==null)return n.value},m.prototype.getReverse=function(r){for(var t=0,n=this.tail;n!==null&&t<r;t++)n=n.prev;if(t===r&&n!==null)return n.value},m.prototype.map=function(r,t){t=t||this;for(var n=new m,s=this.head;s!==null;)n.push(r.call(t,s.value,this)),s=s.next;return n},m.prototype.mapReverse=function(r,t){t=t||this;for(var n=new m,s=this.tail;s!==null;)n.push(r.call(t,s.value,this)),s=s.prev;return n},m.prototype.reduce=function(r,t){var n,s=this.head;if(arguments.length>1)n=t;else if(this.head)s=this.head.next,n=this.head.value;else throw new TypeError("Reduce of empty list with no initial value");for(var v=0;s!==null;v++)n=r(n,s.value,v),s=s.next;return n},m.prototype.reduceReverse=function(r,t){var n,s=this.tail;if(arguments.length>1)n=t;else if(this.tail)s=this.tail.prev,n=this.tail.value;else throw new TypeError("Reduce of empty list with no initial value");for(var v=this.length-1;s!==null;v--)n=r(n,s.value,v),s=s.prev;return n},m.prototype.toArray=function(){for(var r=new Array(this.length),t=0,n=this.head;n!==null;t++)r[t]=n.value,n=n.next;return r},m.prototype.toArrayReverse=function(){for(var r=new Array(this.length),t=0,n=this.tail;n!==null;t++)r[t]=n.value,n=n.prev;return r},m.prototype.slice=function(r,t){t=t||this.length,t<0&&(t+=this.length),r=r||0,r<0&&(r+=this.length);var n=new m;if(t<r||t<0)return n;r<0&&(r=0),t>this.length&&(t=this.length);for(var s=0,v=this.head;v!==null&&s<r;s++)v=v.next;for(;v!==null&&s<t;s++,v=v.next)n.push(v.value);return n},m.prototype.sliceReverse=function(r,t){t=t||this.length,t<0&&(t+=this.length),r=r||0,r<0&&(r+=this.length);var n=new m;if(t<r||t<0)return n;r<0&&(r=0),t>this.length&&(t=this.length);for(var s=this.length,v=this.tail;v!==null&&s>t;s--)v=v.prev;for(;v!==null&&s>r;s--,v=v.prev)n.push(v.value);return n},m.prototype.splice=function(r,t,...n){r>this.length&&(r=this.length-1),r<0&&(r=this.length+r);for(var s=0,v=this.head;v!==null&&s<r;s++)v=v.next;for(var x=[],s=0;v&&s<t;s++)x.push(v.value),v=this.removeNode(v);v===null&&(v=this.tail),v!==this.head&&v!==this.tail&&(v=v.prev);for(var s=0;s<n.length;s++)v=i(this,v,n[s]);return x},m.prototype.reverse=function(){for(var r=this.head,t=this.tail,n=r;n!==null;n=n.prev){var s=n.prev;n.prev=n.next,n.next=s}return this.head=t,this.tail=r,this};function i(r,t,n){var s=t===r.head?new A(n,null,t,r):new A(n,t,t.next,r);return s.next===null&&(r.tail=s),s.prev===null&&(r.head=s),r.length++,s}function g(r,t){r.tail=new A(t,r.tail,null,r),r.head||(r.head=r.tail),r.length++}function h(r,t){r.head=new A(t,null,r.head,r),r.tail||(r.tail=r.head),r.length++}function A(r,t,n,s){if(!(this instanceof A))return new A(r,t,n,s);this.list=s,this.value=r,t?(t.next=this,this.prev=t):this.prev=null,n?(n.prev=this,this.next=n):this.next=null}try{ln()(m)}catch{}return Me}var qe,St;function Xt(){if(St)return qe;St=1;const m=cn(),i=Symbol("max"),g=Symbol("length"),h=Symbol("lengthCalculator"),A=Symbol("allowStale"),r=Symbol("maxAge"),t=Symbol("dispose"),n=Symbol("noDisposeOnSet"),s=Symbol("lruList"),v=Symbol("cache"),x=Symbol("updateAgeOnGet"),D=()=>1;class u{constructor(e){if(typeof e=="number"&&(e={max:e}),e||(e={}),e.max&&(typeof e.max!="number"||e.max<0))throw new TypeError("max must be a non-negative number");this[i]=e.max||1/0;const a=e.length||D;if(this[h]=typeof a!="function"?D:a,this[A]=e.stale||!1,e.maxAge&&typeof e.maxAge!="number")throw new TypeError("maxAge must be a number");this[r]=e.maxAge||0,this[t]=e.dispose,this[n]=e.noDisposeOnSet||!1,this[x]=e.updateAgeOnGet||!1,this.reset()}set max(e){if(typeof e!="number"||e<0)throw new TypeError("max must be a non-negative number");this[i]=e||1/0,N(this)}get max(){return this[i]}set allowStale(e){this[A]=!!e}get allowStale(){return this[A]}set maxAge(e){if(typeof e!="number")throw new TypeError("maxAge must be a non-negative number");this[r]=e,N(this)}get maxAge(){return this[r]}set lengthCalculator(e){typeof e!="function"&&(e=D),e!==this[h]&&(this[h]=e,this[g]=0,this[s].forEach(a=>{a.length=this[h](a.value,a.key),this[g]+=a.length})),N(this)}get lengthCalculator(){return this[h]}get length(){return this[g]}get itemCount(){return this[s].length}rforEach(e,a){a=a||this;for(let c=this[s].tail;c!==null;){const S=c.prev;k(this,e,c,a),c=S}}forEach(e,a){a=a||this;for(let c=this[s].head;c!==null;){const S=c.next;k(this,e,c,a),c=S}}keys(){return this[s].toArray().map(e=>e.key)}values(){return this[s].toArray().map(e=>e.value)}reset(){this[t]&&this[s]&&this[s].length&&this[s].forEach(e=>this[t](e.key,e.value)),this[v]=new Map,this[s]=new m,this[g]=0}dump(){return this[s].map(e=>w(this,e)?!1:{k:e.key,v:e.value,e:e.now+(e.maxAge||0)}).toArray().filter(e=>e)}dumpLru(){return this[s]}set(e,a,c){if(c=c||this[r],c&&typeof c!="number")throw new TypeError("maxAge must be a number");const S=c?Date.now():0,d=this[h](a,e);if(this[v].has(e)){if(d>this[i])return L(this,this[v].get(e)),!1;const F=this[v].get(e).value;return this[t]&&(this[n]||this[t](e,F.value)),F.now=S,F.maxAge=c,F.value=a,this[g]+=d-F.length,F.length=d,this.get(e),N(this),!0}const E=new H(e,a,d,S,c);return E.length>this[i]?(this[t]&&this[t](e,a),!1):(this[g]+=E.length,this[s].unshift(E),this[v].set(e,this[s].head),N(this),!0)}has(e){if(!this[v].has(e))return!1;const a=this[v].get(e).value;return!w(this,a)}get(e){return l(this,e,!0)}peek(e){return l(this,e,!1)}pop(){const e=this[s].tail;return e?(L(this,e),e.value):null}del(e){L(this,this[v].get(e))}load(e){this.reset();const a=Date.now();for(let c=e.length-1;c>=0;c--){const S=e[c],d=S.e||0;if(d===0)this.set(S.k,S.v);else{const E=d-a;E>0&&this.set(S.k,S.v,E)}}}prune(){this[v].forEach((e,a)=>l(this,a,!1))}}const l=(f,e,a)=>{const c=f[v].get(e);if(c){const S=c.value;if(w(f,S)){if(L(f,c),!f[A])return}else a&&(f[x]&&(c.value.now=Date.now()),f[s].unshiftNode(c));return S.value}},w=(f,e)=>{if(!e||!e.maxAge&&!f[r])return!1;const a=Date.now()-e.now;return e.maxAge?a>e.maxAge:f[r]&&a>f[r]},N=f=>{if(f[g]>f[i])for(let e=f[s].tail;f[g]>f[i]&&e!==null;){const a=e.prev;L(f,e),e=a}},L=(f,e)=>{if(e){const a=e.value;f[t]&&f[t](a.key,a.value),f[g]-=a.length,f[v].delete(a.key),f[s].removeNode(e)}};class H{constructor(e,a,c,S,d){this.key=e,this.value=a,this.length=c,this.now=S,this.maxAge=d||0}}const k=(f,e,a,c)=>{let S=a.value;w(f,S)&&(L(f,a),f[A]||(S=void 0)),S&&e.call(c,S.value,S.key,f)};return qe=u,qe}var Fe,_t;function un(){if(_t)return Fe;_t=1;const m=Xt(),i=10;return Fe=class{constructor({document:h}){this.document=h,this.cache=new m({max:i})}getProcessed(h){return this.cache.get(h)}setProcessed(h,A){this.cache.set(h,A)}},Fe}var Je,Rt;function dn(){if(Rt)return Je;Rt=1;const{isArray:m,isObject:i,isString:g}=ee(),{asArray:h}=te(),{prependBase:A}=ae(),r=ne(),t=un(),n=10;Je=class{constructor({sharedCache:D}){this.perOpCache=new Map,this.sharedCache=D}async resolve({activeCtx:D,context:u,documentLoader:l,base:w,cycles:N=new Set}){u&&i(u)&&u["@context"]&&(u=u["@context"]),u=h(u);const L=[];for(const H of u){if(g(H)){let e=this._get(H);e||(e=await this._resolveRemoteContext({activeCtx:D,url:H,documentLoader:l,base:w,cycles:N})),m(e)?L.push(...e):L.push(e);continue}if(H===null){L.push(new t({document:null}));continue}i(H)||s(u);const k=JSON.stringify(H);let f=this._get(k);f||(f=new t({document:H}),this._cacheResolvedContext({key:k,resolved:f,tag:"static"})),L.push(f)}return L}_get(D){let u=this.perOpCache.get(D);if(!u){const l=this.sharedCache.get(D);l&&(u=l.get("static"),u&&this.perOpCache.set(D,u))}return u}_cacheResolvedContext({key:D,resolved:u,tag:l}){if(this.perOpCache.set(D,u),l!==void 0){let w=this.sharedCache.get(D);w||(w=new Map,this.sharedCache.set(D,w)),w.set(l,u)}return u}async _resolveRemoteContext({activeCtx:D,url:u,documentLoader:l,base:w,cycles:N}){u=A(w,u);const{context:L,remoteDoc:H}=await this._fetchContext({activeCtx:D,url:u,documentLoader:l,cycles:N});w=H.documentUrl||u,v({context:L,base:w});const k=await this.resolve({activeCtx:D,context:L,documentLoader:l,base:w,cycles:N});return this._cacheResolvedContext({key:u,resolved:k,tag:H.tag}),k}async _fetchContext({activeCtx:D,url:u,documentLoader:l,cycles:w}){if(w.size>n)throw new r("Maximum number of @context URLs exceeded.","jsonld.ContextUrlError",{code:D.processingMode==="json-ld-1.0"?"loading remote context failed":"context overflow",max:n});if(w.has(u))throw new r("Cyclical @context URLs detected.","jsonld.ContextUrlError",{code:D.processingMode==="json-ld-1.0"?"recursive context inclusion":"context overflow",url:u});w.add(u);let N,L;try{L=await l(u),N=L.document||null,g(N)&&(N=JSON.parse(N))}catch(H){throw new r(`Dereferencing a URL did not result in a valid JSON-LD object. Possible causes are an inaccessible URL perhaps due to a same-origin policy (ensure the server uses CORS if you are using client-side JavaScript), too many redirects, a non-JSON response, or more than one HTTP Link Header was provided for a remote context. URL: "${u}".`,"jsonld.InvalidUrl",{code:"loading remote context failed",url:u,cause:H})}if(!i(N))throw new r(`Dereferencing a URL did not result in a JSON object. The response was valid JSON, but it was not a JSON object. URL: "${u}".`,"jsonld.InvalidUrl",{code:"invalid remote context",url:u});return"@context"in N?N={"@context":N["@context"]}:N={"@context":{}},L.contextUrl&&(m(N["@context"])||(N["@context"]=[N["@context"]]),N["@context"].push(L.contextUrl)),{context:N,remoteDoc:L}}};function s(x){throw new r("Invalid JSON-LD syntax; @context must be an object.","jsonld.SyntaxError",{code:"invalid local context",context:x})}function v({context:x,base:D}){if(!x)return;const u=x["@context"];if(g(u)){x["@context"]=A(D,u);return}if(m(u)){for(let l=0;l<u.length;++l){const w=u[l];if(g(w)){u[l]=A(D,w);continue}i(w)&&v({context:{"@context":w},base:D})}return}if(i(u))for(const l in u)v({context:u[l],base:D})}return Je}var He,Dt;function fn(){return Dt||(Dt=1,He=et().NQuads),He}var Be,Lt;function se(){if(Lt)return Be;Lt=1;const m=ne(),{isArray:i}=ee(),{asArray:g}=te(),h={};Be=h,h.defaultEventHandler=null,h.setupEventHandler=({options:t={}})=>{const n=[].concat(t.safe?h.safeEventHandler:[],t.eventHandler?g(t.eventHandler):[],h.defaultEventHandler?h.defaultEventHandler:[]);return n.length===0?null:n},h.handleEvent=({event:t,options:n})=>{A({event:t,handlers:n.eventHandler})};function A({event:t,handlers:n}){let s=!0;for(let v=0;s&&v<n.length;++v){s=!1;const x=n[v];if(i(x))s=A({event:t,handlers:x});else if(typeof x=="function")x({event:t,next:()=>{s=!0}});else if(typeof x=="object")t.code in x?x[t.code]({event:t,next:()=>{s=!0}}):s=!0;else throw new m("Invalid event handler.","jsonld.InvalidEventHandler",{event:t})}return s}const r=new Set(["empty object","free-floating scalar","invalid @language value","invalid property","null @id value","null @value value","object with only @id","object with only @language","object with only @list","object with only @value","relative @id reference","relative @type reference","relative @vocab reference","reserved @id value","reserved @reverse value","reserved term","blank node predicate","relative graph reference","relative object reference","relative predicate reference","relative subject reference","rdfDirection not set"]);return h.safeEventHandler=function({event:n,next:s}){if(n.level==="warning"&&r.has(n.code))throw new m("Safe mode validation error.","jsonld.ValidationError",{event:n});s()},h.logEventHandler=function({event:n,next:s}){console.log(`EVENT: ${n.message}`,{event:n}),s()},h.logWarningEventHandler=function({event:n,next:s}){n.level==="warning"&&console.warn(`WARNING: ${n.message}`,{event:n}),s()},h.unhandledEventHandler=function({event:n}){throw new m("No handler for event.","jsonld.UnhandledEvent",{event:n})},h.setDefaultEventHandler=function({eventHandler:t}={}){h.defaultEventHandler=t?g(t):null},Be}var Ue,Ot;function ie(){if(Ot)return Ue;Ot=1;const m=te(),i=ne(),{isArray:g,isObject:h,isString:A,isUndefined:r}=ee(),{isAbsolute:t,isRelative:n,prependBase:s}=ae(),{handleEvent:v}=se(),{REGEX_BCP47:x,REGEX_KEYWORD:D,asArray:u,compareShortestLeast:l}=te(),w=new Map,N=1e4,L={};Ue=L,L.process=async({activeCtx:f,localCtx:e,options:a,propagate:c=!0,overrideProtected:S=!1,cycles:d=new Set})=>{if(h(e)&&"@context"in e&&g(e["@context"])&&(e=e["@context"]),u(e).length===0)return f;const b=[],F=[({event:J,next:o})=>{b.push(J),o()}];a.eventHandler&&F.push(a.eventHandler);const M=a;a={...a,eventHandler:F};const j=await a.contextResolver.resolve({activeCtx:f,context:e,documentLoader:a.documentLoader,base:a.base});h(j[0].document)&&typeof j[0].document["@propagate"]=="boolean"&&(c=j[0].document["@propagate"]);let p=f;!c&&!p.previousContext&&(p=p.clone(),p.previousContext=f);for(const J of j){let{document:o}=J;if(f=p,o===null){if(!S&&Object.keys(f.protected).length!==0)throw new i("Tried to nullify a context with protected terms outside of a term definition.","jsonld.SyntaxError",{code:"invalid context nullification"});p=f=L.getInitialContext(a).clone();continue}const T=J.getProcessed(f);if(T){if(M.eventHandler)for(const q of T.events)v({event:q,options:M});p=f=T.context;continue}if(h(o)&&"@context"in o&&(o=o["@context"]),!h(o))throw new i("Invalid JSON-LD syntax; @context must be an object.","jsonld.SyntaxError",{code:"invalid local context",context:o});p=p.clone();const O=new Map;if("@version"in o){if(o["@version"]!==1.1)throw new i("Unsupported JSON-LD version: "+o["@version"],"jsonld.UnsupportedVersion",{code:"invalid @version value",context:o});if(f.processingMode&&f.processingMode==="json-ld-1.0")throw new i("@version: "+o["@version"]+" not compatible with "+f.processingMode,"jsonld.ProcessingModeConflict",{code:"processing mode conflict",context:o});p.processingMode="json-ld-1.1",p["@version"]=o["@version"],O.set("@version",!0)}if(p.processingMode=p.processingMode||f.processingMode,"@base"in o){let q=o["@base"];if(!(q===null||t(q)))if(n(q))q=s(p["@base"],q);else throw new i('Invalid JSON-LD syntax; the value of "@base" in a @context must be an absolute IRI, a relative IRI, or null.',"jsonld.SyntaxError",{code:"invalid base IRI",context:o});p["@base"]=q,O.set("@base",!0)}if("@vocab"in o){const q=o["@vocab"];if(q===null)delete p["@vocab"];else if(A(q)){if(!t(q)&&L.processingMode(p,1))throw new i('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be an absolute IRI.',"jsonld.SyntaxError",{code:"invalid vocab mapping",context:o});{const y=H(p,q,{vocab:!0,base:!0},void 0,void 0,a);t(y)||a.eventHandler&&v({event:{type:["JsonLdEvent"],code:"relative @vocab reference",level:"warning",message:"Relative @vocab reference found.",details:{vocab:y}},options:a}),p["@vocab"]=y}}else throw new i('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid vocab mapping",context:o});O.set("@vocab",!0)}if("@language"in o){const q=o["@language"];if(q===null)delete p["@language"];else if(A(q))q.match(x)||a.eventHandler&&v({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:q}},options:a}),p["@language"]=q.toLowerCase();else throw new i('Invalid JSON-LD syntax; the value of "@language" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid default language",context:o});O.set("@language",!0)}if("@direction"in o){const q=o["@direction"];if(f.processingMode==="json-ld-1.0")throw new i("Invalid JSON-LD syntax; @direction not compatible with "+f.processingMode,"jsonld.SyntaxError",{code:"invalid context member",context:o});if(q===null)delete p["@direction"];else{if(q!=="ltr"&&q!=="rtl")throw new i('Invalid JSON-LD syntax; the value of "@direction" in a @context must be null, "ltr", or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",context:o});p["@direction"]=q}O.set("@direction",!0)}if("@propagate"in o){const q=o["@propagate"];if(f.processingMode==="json-ld-1.0")throw new i("Invalid JSON-LD syntax; @propagate not compatible with "+f.processingMode,"jsonld.SyntaxError",{code:"invalid context entry",context:o});if(typeof q!="boolean")throw new i("Invalid JSON-LD syntax; @propagate value must be a boolean.","jsonld.SyntaxError",{code:"invalid @propagate value",context:e});O.set("@propagate",!0)}if("@import"in o){const q=o["@import"];if(f.processingMode==="json-ld-1.0")throw new i("Invalid JSON-LD syntax; @import not compatible with "+f.processingMode,"jsonld.SyntaxError",{code:"invalid context entry",context:o});if(!A(q))throw new i("Invalid JSON-LD syntax; @import must be a string.","jsonld.SyntaxError",{code:"invalid @import value",context:e});const y=await a.contextResolver.resolve({activeCtx:f,context:q,documentLoader:a.documentLoader,base:a.base});if(y.length!==1)throw new i("Invalid JSON-LD syntax; @import must reference a single context.","jsonld.SyntaxError",{code:"invalid remote context",context:e});const G=y[0].getProcessed(f);if(G)o=G;else{const B=y[0].document;if("@import"in B)throw new i("Invalid JSON-LD syntax: imported context must not include @import.","jsonld.SyntaxError",{code:"invalid context entry",context:e});for(const V in B)o.hasOwnProperty(V)||(o[V]=B[V]);y[0].setProcessed(f,o)}O.set("@import",!0)}O.set("@protected",o["@protected"]||!1);for(const q in o)if(L.createTermDefinition({activeCtx:p,localCtx:o,term:q,defined:O,options:a,overrideProtected:S}),h(o[q])&&"@context"in o[q]){const y=o[q]["@context"];let G=!0;if(A(y)){const B=s(a.base,y);d.has(B)?G=!1:d.add(B)}if(G)try{await L.process({activeCtx:p.clone(),localCtx:o[q]["@context"],overrideProtected:!0,options:a,cycles:d})}catch{throw new i("Invalid JSON-LD syntax; invalid scoped context.","jsonld.SyntaxError",{code:"invalid scoped context",context:o[q]["@context"],term:q})}}J.setProcessed(f,{context:p,events:b})}return p},L.createTermDefinition=({activeCtx:f,localCtx:e,term:a,defined:c,options:S,overrideProtected:d=!1})=>{if(c.has(a)){if(c.get(a))return;throw new i("Cyclical context definition detected.","jsonld.CyclicalContext",{code:"cyclic IRI mapping",context:e,term:a})}c.set(a,!1);let E;if(e.hasOwnProperty(a)&&(E=e[a]),a==="@type"&&h(E)&&(E["@container"]||"@set")==="@set"&&L.processingMode(f,1.1)){const o=["@container","@id","@protected"],T=Object.keys(E);if(T.length===0||T.some(O=>!o.includes(O)))throw new i("Invalid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{code:"keyword redefinition",context:e,term:a})}else{if(L.isKeyword(a))throw new i("Invalid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{code:"keyword redefinition",context:e,term:a});if(a.match(D)){S.eventHandler&&v({event:{type:["JsonLdEvent"],code:"reserved term",level:"warning",message:'Terms beginning with "@" are reserved for future use and dropped.',details:{term:a}},options:S});return}else if(a==="")throw new i("Invalid JSON-LD syntax; a term cannot be an empty string.","jsonld.SyntaxError",{code:"invalid term definition",context:e})}const b=f.mappings.get(a);f.mappings.has(a)&&f.mappings.delete(a);let F=!1;if((A(E)||E===null)&&(F=!0,E={"@id":E}),!h(E))throw new i("Invalid JSON-LD syntax; @context term values must be strings or objects.","jsonld.SyntaxError",{code:"invalid term definition",context:e});const M={};f.mappings.set(a,M),M.reverse=!1;const j=["@container","@id","@language","@reverse","@type"];L.processingMode(f,1.1)&&j.push("@context","@direction","@index","@nest","@prefix","@protected");for(const o in E)if(!j.includes(o))throw new i("Invalid JSON-LD syntax; a term definition must not contain "+o,"jsonld.SyntaxError",{code:"invalid term definition",context:e});const p=a.indexOf(":");if(M._termHasColon=p>0,"@reverse"in E){if("@id"in E)throw new i("Invalid JSON-LD syntax; a @reverse term definition must not contain @id.","jsonld.SyntaxError",{code:"invalid reverse property",context:e});if("@nest"in E)throw new i("Invalid JSON-LD syntax; a @reverse term definition must not contain @nest.","jsonld.SyntaxError",{code:"invalid reverse property",context:e});const o=E["@reverse"];if(!A(o))throw new i("Invalid JSON-LD syntax; a @context @reverse value must be a string.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e});if(o.match(D)){S.eventHandler&&v({event:{type:["JsonLdEvent"],code:"reserved @reverse value",level:"warning",message:'@reverse values beginning with "@" are reserved for future use and dropped.',details:{reverse:o}},options:S}),b?f.mappings.set(a,b):f.mappings.delete(a);return}const T=H(f,o,{vocab:!0,base:!1},e,c,S);if(!t(T))throw new i("Invalid JSON-LD syntax; a @context @reverse value must be an absolute IRI or a blank node identifier.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e});M["@id"]=T,M.reverse=!0}else if("@id"in E){let o=E["@id"];if(o&&!A(o))throw new i("Invalid JSON-LD syntax; a @context @id value must be an array of strings or a string.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e});if(o===null)M["@id"]=null;else if(!L.isKeyword(o)&&o.match(D)){S.eventHandler&&v({event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:'@id values beginning with "@" are reserved for future use and dropped.',details:{id:o}},options:S}),b?f.mappings.set(a,b):f.mappings.delete(a);return}else if(o!==a){if(o=H(f,o,{vocab:!0,base:!1},e,c,S),!t(o)&&!L.isKeyword(o))throw new i("Invalid JSON-LD syntax; a @context @id value must be an absolute IRI, a blank node identifier, or a keyword.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e});if(a.match(/(?::[^:])|\//)){const T=new Map(c).set(a,!0);if(H(f,a,{vocab:!0,base:!1},e,T,S)!==o)throw new i("Invalid JSON-LD syntax; term in form of IRI must expand to definition.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e})}M["@id"]=o,M._prefix=F&&!M._termHasColon&&o.match(/[:\/\?#\[\]@]$/)!==null}}if(!("@id"in M))if(M._termHasColon){const o=a.substr(0,p);if(e.hasOwnProperty(o)&&L.createTermDefinition({activeCtx:f,localCtx:e,term:o,defined:c,options:S}),f.mappings.has(o)){const T=a.substr(p+1);M["@id"]=f.mappings.get(o)["@id"]+T}else M["@id"]=a}else if(a==="@type")M["@id"]=a;else{if(!("@vocab"in f))throw new i("Invalid JSON-LD syntax; @context terms must define an @id.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e,term:a});M["@id"]=f["@vocab"]+a}if((E["@protected"]===!0||c.get("@protected")===!0&&E["@protected"]!==!1)&&(f.protected[a]=!0,M.protected=!0),c.set(a,!0),"@type"in E){let o=E["@type"];if(!A(o))throw new i("Invalid JSON-LD syntax; an @context @type value must be a string.","jsonld.SyntaxError",{code:"invalid type mapping",context:e});if(o==="@json"||o==="@none"){if(L.processingMode(f,1))throw new i(`Invalid JSON-LD syntax; an @context @type value must not be "${o}" in JSON-LD 1.0 mode.`,"jsonld.SyntaxError",{code:"invalid type mapping",context:e})}else if(o!=="@id"&&o!=="@vocab"){if(o=H(f,o,{vocab:!0,base:!1},e,c,S),!t(o))throw new i("Invalid JSON-LD syntax; an @context @type value must be an absolute IRI.","jsonld.SyntaxError",{code:"invalid type mapping",context:e});if(o.indexOf("_:")===0)throw new i("Invalid JSON-LD syntax; an @context @type value must be an IRI, not a blank node identifier.","jsonld.SyntaxError",{code:"invalid type mapping",context:e})}M["@type"]=o}if("@container"in E){const o=A(E["@container"])?[E["@container"]]:E["@container"]||[],T=["@list","@set","@index","@language"];let O=!0;const q=o.includes("@set");if(L.processingMode(f,1.1)){if(T.push("@graph","@id","@type"),o.includes("@list")){if(o.length!==1)throw new i("Invalid JSON-LD syntax; @context @container with @list must have no other values","jsonld.SyntaxError",{code:"invalid container mapping",context:e})}else if(o.includes("@graph")){if(o.some(y=>y!=="@graph"&&y!=="@id"&&y!=="@index"&&y!=="@set"))throw new i("Invalid JSON-LD syntax; @context @container with @graph must have no other values other than @id, @index, and @set","jsonld.SyntaxError",{code:"invalid container mapping",context:e})}else O&=o.length<=(q?2:1);if(o.includes("@type")&&(M["@type"]=M["@type"]||"@id",!["@id","@vocab"].includes(M["@type"])))throw new i("Invalid JSON-LD syntax; container: @type requires @type to be @id or @vocab.","jsonld.SyntaxError",{code:"invalid type mapping",context:e})}else O&=!g(E["@container"]),O&=o.length<=1;if(O&=o.every(y=>T.includes(y)),O&=!(q&&o.includes("@list")),!O)throw new i("Invalid JSON-LD syntax; @context @container value must be one of the following: "+T.join(", "),"jsonld.SyntaxError",{code:"invalid container mapping",context:e});if(M.reverse&&!o.every(y=>["@index","@set"].includes(y)))throw new i("Invalid JSON-LD syntax; @context @container value for a @reverse type definition must be @index or @set.","jsonld.SyntaxError",{code:"invalid reverse property",context:e});M["@container"]=o}if("@index"in E){if(!("@container"in E)||!M["@container"].includes("@index"))throw new i(`Invalid JSON-LD syntax; @index without @index in @container: "${E["@index"]}" on term "${a}".`,"jsonld.SyntaxError",{code:"invalid term definition",context:e});if(!A(E["@index"])||E["@index"].indexOf("@")===0)throw new i(`Invalid JSON-LD syntax; @index must expand to an IRI: "${E["@index"]}" on term "${a}".`,"jsonld.SyntaxError",{code:"invalid term definition",context:e});M["@index"]=E["@index"]}if("@context"in E&&(M["@context"]=E["@context"]),"@language"in E&&!("@type"in E)){let o=E["@language"];if(o!==null&&!A(o))throw new i("Invalid JSON-LD syntax; @context @language value must be a string or null.","jsonld.SyntaxError",{code:"invalid language mapping",context:e});o!==null&&(o=o.toLowerCase()),M["@language"]=o}if("@prefix"in E){if(a.match(/:|\//))throw new i("Invalid JSON-LD syntax; @context @prefix used on a compact IRI term","jsonld.SyntaxError",{code:"invalid term definition",context:e});if(L.isKeyword(M["@id"]))throw new i("Invalid JSON-LD syntax; keywords may not be used as prefixes","jsonld.SyntaxError",{code:"invalid term definition",context:e});if(typeof E["@prefix"]=="boolean")M._prefix=E["@prefix"]===!0;else throw new i("Invalid JSON-LD syntax; @context value for @prefix must be boolean","jsonld.SyntaxError",{code:"invalid @prefix value",context:e})}if("@direction"in E){const o=E["@direction"];if(o!==null&&o!=="ltr"&&o!=="rtl")throw new i('Invalid JSON-LD syntax; @direction value must be null, "ltr", or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",context:e});M["@direction"]=o}if("@nest"in E){const o=E["@nest"];if(!A(o)||o!=="@nest"&&o.indexOf("@")===0)throw new i("Invalid JSON-LD syntax; @context @nest value must be a string which is not a keyword other than @nest.","jsonld.SyntaxError",{code:"invalid @nest value",context:e});M["@nest"]=o}// disallow aliasing @context and @preserve
const J=M["@id"];if(J==="@context"||J==="@preserve")throw new i("Invalid JSON-LD syntax; @context and @preserve cannot be aliased.","jsonld.SyntaxError",{code:"invalid keyword alias",context:e});if(b&&b.protected&&!d&&(f.protected[a]=!0,M.protected=!0,!k(b,M)))throw new i("Invalid JSON-LD syntax; tried to redefine a protected term.","jsonld.SyntaxError",{code:"protected term redefinition",context:e,term:a})},L.expandIri=(f,e,a,c)=>H(f,e,a,void 0,void 0,c);function H(f,e,a,c,S,d){if(e===null||!A(e)||L.isKeyword(e))return e;if(e.match(D))return null;if(c&&c.hasOwnProperty(e)&&S.get(e)!==!0&&L.createTermDefinition({activeCtx:f,localCtx:c,term:e,defined:S,options:d}),a=a||{},a.vocab){const b=f.mappings.get(e);if(b===null)return null;if(h(b)&&"@id"in b)return b["@id"]}const E=e.indexOf(":");if(E>0){const b=e.substr(0,E),F=e.substr(E+1);if(b==="_"||F.indexOf("//")===0)return e;c&&c.hasOwnProperty(b)&&L.createTermDefinition({activeCtx:f,localCtx:c,term:b,defined:S,options:d});const M=f.mappings.get(b);if(M&&M._prefix)return M["@id"]+F;if(t(e))return e}if(a.vocab&&"@vocab"in f)e=f["@vocab"]+e;else if(a.base){let b,F;"@base"in f?f["@base"]?(F=s(d.base,f["@base"]),b=s(F,e)):(F=f["@base"],b=e):(F=d.base,b=s(d.base,e)),e=b}return e}L.getInitialContext=f=>{const e=JSON.stringify({processingMode:f.processingMode}),a=w.get(e);if(a)return a;const c={processingMode:f.processingMode,mappings:new Map,inverse:null,getInverse:S,clone:b,revertToPreviousContext:F,protected:{}};return w.size===N&&w.clear(),w.set(e,c),c;function S(){const M=this;if(M.inverse)return M.inverse;const j=M.inverse={},p=M.fastCurieMap={},J={},o=(M["@language"]||"@none").toLowerCase(),T=M["@direction"],O=M.mappings,q=[...O.keys()].sort(l);for(const y of q){const G=O.get(y);if(G===null)continue;let B=G["@container"]||"@none";if(B=[].concat(B).sort().join(""),G["@id"]===null)continue;const V=u(G["@id"]);for(const X of V){let R=j[X];const I=L.isKeyword(X);if(R)!I&&!G._termHasColon&&J[X].push(y);else if(j[X]=R={},!I&&!G._termHasColon){J[X]=[y];const _={iri:X,terms:J[X]};X[0]in p?p[X[0]].push(_):p[X[0]]=[_]}if(R[B]||(R[B]={"@language":{},"@type":{},"@any":{}}),R=R[B],E(y,R["@any"],"@none"),G.reverse)E(y,R["@type"],"@reverse");else if(G["@type"]==="@none")E(y,R["@any"],"@none"),E(y,R["@language"],"@none"),E(y,R["@type"],"@none");else if("@type"in G)E(y,R["@type"],G["@type"]);else if("@language"in G&&"@direction"in G){const _=G["@language"],P=G["@direction"];_&&P?E(y,R["@language"],`${_}_${P}`.toLowerCase()):_?E(y,R["@language"],_.toLowerCase()):P?E(y,R["@language"],`_${P}`):E(y,R["@language"],"@null")}else"@language"in G?E(y,R["@language"],(G["@language"]||"@null").toLowerCase()):"@direction"in G?G["@direction"]?E(y,R["@language"],`_${G["@direction"]}`):E(y,R["@language"],"@none"):T?(E(y,R["@language"],`_${T}`),E(y,R["@language"],"@none"),E(y,R["@type"],"@none")):(E(y,R["@language"],o),E(y,R["@language"],"@none"),E(y,R["@type"],"@none"))}}for(const y in p)d(p,y,1);return j}function d(M,j,p){const J=M[j],o=M[j]={};let T,O;for(const q of J)T=q.iri,p>=T.length?O="":O=T[p],O in o?o[O].push(q):o[O]=[q];for(const q in o)q!==""&&d(o,q,p+1)}function E(M,j,p){j.hasOwnProperty(p)||(j[p]=M)}function b(){const M={};return M.mappings=m.clone(this.mappings),M.clone=this.clone,M.inverse=null,M.getInverse=this.getInverse,M.protected=m.clone(this.protected),this.previousContext&&(M.previousContext=this.previousContext.clone()),M.revertToPreviousContext=this.revertToPreviousContext,"@base"in this&&(M["@base"]=this["@base"]),"@language"in this&&(M["@language"]=this["@language"]),"@vocab"in this&&(M["@vocab"]=this["@vocab"]),M}function F(){return this.previousContext?this.previousContext.clone():this}},L.getContextValue=(f,e,a)=>{if(e===null)return a==="@context"?void 0:null;if(f.mappings.has(e)){const c=f.mappings.get(e);if(r(a))return c;if(c.hasOwnProperty(a))return c[a]}if(a==="@language"&&a in f||a==="@direction"&&a in f)return f[a];if(a!=="@context")return null},L.processingMode=(f,e)=>e.toString()>="1.1"?!f.processingMode||f.processingMode>="json-ld-"+e.toString():f.processingMode==="json-ld-1.0",L.isKeyword=f=>{if(!A(f)||f[0]!=="@")return!1;switch(f){case"@base":case"@container":case"@context":case"@default":case"@direction":case"@embed":case"@explicit":case"@graph":case"@id":case"@included":case"@index":case"@json":case"@language":case"@list":case"@nest":case"@none":case"@omitDefault":case"@prefix":case"@preserve":case"@protected":case"@requireAll":case"@reverse":case"@set":case"@type":case"@value":case"@version":case"@vocab":return!0}return!1};function k(f,e){if(!(f&&typeof f=="object")||!(e&&typeof e=="object"))return f===e;const a=Array.isArray(f);if(a!==Array.isArray(e))return!1;if(a){if(f.length!==e.length)return!1;for(let d=0;d<f.length;++d)if(!k(f[d],e[d]))return!1;return!0}const c=Object.keys(f),S=Object.keys(e);if(c.length!==S.length)return!1;for(const d in f){let E=f[d],b=e[d];if(d==="@container"&&Array.isArray(E)&&Array.isArray(b)&&(E=E.slice().sort(),b=b.slice().sort()),!k(E,b))return!1}return!0}return Ue}var Pe,At;function hn(){if(At)return Pe;At=1;const m=ne(),{isArray:i,isObject:g,isEmptyObject:h,isString:A,isUndefined:r}=ee(),{isList:t,isValue:n,isGraph:s,isSubject:v}=re(),{expandIri:x,getContextValue:D,isKeyword:u,process:l,processingMode:w}=ie(),{isAbsolute:N}=ae(),{REGEX_BCP47:L,REGEX_KEYWORD:H,addValue:k,asArray:f,getValues:e,validateTypeValue:a}=te(),{handleEvent:c}=se(),S={};Pe=S,S.expand=async({activeCtx:j,activeProperty:p=null,element:J,options:o={},insideList:T=!1,insideIndex:O=!1,typeScopedContext:q=null})=>{if(J==null)return null;if(p==="@default"&&(o=Object.assign({},o,{isFrame:!1})),!i(J)&&!g(J))return!T&&(p===null||x(j,p,{vocab:!0},o)==="@graph")?(o.eventHandler&&c({event:{type:["JsonLdEvent"],code:"free-floating scalar",level:"warning",message:"Dropping free-floating scalar not in a list.",details:{value:J}},options:o}),null):b({activeCtx:j,activeProperty:p,value:J,options:o});if(i(J)){let _=[];const P=D(j,p,"@container")||[];T=T||P.includes("@list");for(let z=0;z<J.length;++z){let U=await S.expand({activeCtx:j,activeProperty:p,element:J[z],options:o,insideIndex:O,typeScopedContext:q});T&&i(U)&&(U={"@list":U}),U!==null&&(i(U)?_=_.concat(U):_.push(U))}return _}const y=x(j,p,{vocab:!0},o),G=D(j,p,"@context");q=q||(j.previousContext?j:null);let B=Object.keys(J).sort(),V=!O;if(V&&q&&B.length<=2&&!B.includes("@context"))for(const _ of B){const P=x(q,_,{vocab:!0},o);if(P==="@value"){V=!1,j=q;break}if(P==="@id"&&B.length===1){V=!1;break}}V&&(j=j.revertToPreviousContext()),r(G)||(j=await l({activeCtx:j,localCtx:G,propagate:!0,overrideProtected:!0,options:o})),"@context"in J&&(j=await l({activeCtx:j,localCtx:J["@context"],options:o})),q=j;let X=null;for(const _ of B)if(x(j,_,{vocab:!0},o)==="@type"){X=X||_;const z=J[_],U=Array.isArray(z)?z.length>1?z.slice().sort():z:[z];for(const Q of U){const W=D(q,Q,"@context");r(W)||(j=await l({activeCtx:j,localCtx:W,options:o,propagate:!1}))}}let R={};await E({activeCtx:j,activeProperty:p,expandedActiveProperty:y,element:J,expandedParent:R,options:o,insideList:T,typeKey:X,typeScopedContext:q}),B=Object.keys(R);let I=B.length;if("@value"in R){if("@type"in R&&("@language"in R||"@direction"in R))throw new m('Invalid JSON-LD syntax; an element containing "@value" may not contain both "@type" and either "@language" or "@direction".',"jsonld.SyntaxError",{code:"invalid value object",element:R});let _=I-1;if("@type"in R&&(_-=1),"@index"in R&&(_-=1),"@language"in R&&(_-=1),"@direction"in R&&(_-=1),_!==0)throw new m('Invalid JSON-LD syntax; an element containing "@value" may only have an "@index" property and either "@type" or either or both "@language" or "@direction".',"jsonld.SyntaxError",{code:"invalid value object",element:R});const P=R["@value"]===null?[]:f(R["@value"]),z=e(R,"@type");if(!(w(j,1.1)&&z.includes("@json")&&z.length===1))if(P.length===0)o.eventHandler&&c({event:{type:["JsonLdEvent"],code:"null @value value",level:"warning",message:"Dropping null @value value.",details:{value:R}},options:o}),R=null;else{if(!P.every(U=>A(U)||h(U))&&"@language"in R)throw new m("Invalid JSON-LD syntax; only strings may be language-tagged.","jsonld.SyntaxError",{code:"invalid language-tagged value",element:R});if(!z.every(U=>N(U)&&!(A(U)&&U.indexOf("_:")===0)||h(U)))throw new m('Invalid JSON-LD syntax; an element containing "@value" and "@type" must have an absolute IRI for the value of "@type".',"jsonld.SyntaxError",{code:"invalid typed value",element:R})}}else if("@type"in R&&!i(R["@type"]))R["@type"]=[R["@type"]];else if("@set"in R||"@list"in R){if(I>1&&!(I===2&&"@index"in R))throw new m('Invalid JSON-LD syntax; if an element has the property "@set" or "@list", then it can have at most one other property that is "@index".',"jsonld.SyntaxError",{code:"invalid set or list object",element:R});"@set"in R&&(R=R["@set"],B=Object.keys(R),I=B.length)}else I===1&&"@language"in R&&(o.eventHandler&&c({event:{type:["JsonLdEvent"],code:"object with only @language",level:"warning",message:"Dropping object with only @language.",details:{value:R}},options:o}),R=null);return g(R)&&!o.keepFreeFloatingNodes&&!T&&(p===null||y==="@graph"||(D(j,p,"@container")||[]).includes("@graph"))&&(R=d({value:R,count:I,options:o})),R};function d({value:j,count:p,options:J}){if(p===0||"@value"in j||"@list"in j||p===1&&"@id"in j){if(J.eventHandler){let o,T;p===0?(o="empty object",T="Dropping empty object."):"@value"in j?(o="object with only @value",T="Dropping object with only @value."):"@list"in j?(o="object with only @list",T="Dropping object with only @list."):p===1&&"@id"in j&&(o="object with only @id",T="Dropping object with only @id."),c({event:{type:["JsonLdEvent"],code:o,level:"warning",message:T,details:{value:j}},options:J})}return null}return j}async function E({activeCtx:j,activeProperty:p,expandedActiveProperty:J,element:o,expandedParent:T,options:O={},insideList:q,typeKey:y,typeScopedContext:G}){const B=Object.keys(o).sort(),V=[];let X;const R=o[y]&&x(j,i(o[y])?o[y][0]:o[y],{vocab:!0},{...O,typeExpansion:!0})==="@json";for(const I of B){let _=o[I],P;if(I==="@context")continue;const z=x(j,I,{vocab:!0},O);if(z===null||!(N(z)||u(z))){O.eventHandler&&c({event:{type:["JsonLdEvent"],code:"invalid property",level:"warning",message:"Dropping property that did not expand into an absolute IRI or keyword.",details:{property:I,expandedProperty:z}},options:O});continue}if(u(z)){if(J==="@reverse")throw new m("Invalid JSON-LD syntax; a keyword cannot be used as a @reverse property.","jsonld.SyntaxError",{code:"invalid reverse property map",value:_});if(z in T&&z!=="@included"&&z!=="@type")throw new m("Invalid JSON-LD syntax; colliding keywords detected.","jsonld.SyntaxError",{code:"colliding keywords",keyword:z})}if(z==="@id"){if(!A(_)){if(!O.isFrame)throw new m('Invalid JSON-LD syntax; "@id" value must a string.',"jsonld.SyntaxError",{code:"invalid @id value",value:_});if(g(_)){if(!h(_))throw new m('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:_})}else if(i(_)){if(!_.every($=>A($)))throw new m('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:_})}else throw new m('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:_})}k(T,"@id",f(_).map($=>{if(A($)){const K=x(j,$,{base:!0},O);return O.eventHandler&&(K===null?c($===null?{event:{type:["JsonLdEvent"],code:"null @id value",level:"warning",message:"Null @id found.",details:{id:$}},options:O}:{event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:"Reserved @id found.",details:{id:$}},options:O}):N(K)||c({event:{type:["JsonLdEvent"],code:"relative @id reference",level:"warning",message:"Relative @id reference found.",details:{id:$,expandedId:K}},options:O})),K}return $}),{propertyIsArray:O.isFrame});continue}if(z==="@type"){g(_)&&(_=Object.fromEntries(Object.entries(_).map(([$,K])=>[x(G,$,{vocab:!0}),f(K).map(Y=>x(G,Y,{base:!0,vocab:!0},{...O,typeExpansion:!0}))]))),a(_,O.isFrame),k(T,"@type",f(_).map($=>{if(A($)){const K=x(G,$,{base:!0,vocab:!0},{...O,typeExpansion:!0});return K!=="@json"&&!N(K)&&O.eventHandler&&c({event:{type:["JsonLdEvent"],code:"relative @type reference",level:"warning",message:"Relative @type reference found.",details:{type:$}},options:O}),K}return $}),{propertyIsArray:!!O.isFrame});continue}if(z==="@included"&&w(j,1.1)){const $=f(await S.expand({activeCtx:j,activeProperty:p,element:_,options:O}));if(!$.every(K=>v(K)))throw new m("Invalid JSON-LD syntax; values of @included must expand to node objects.","jsonld.SyntaxError",{code:"invalid @included value",value:_});k(T,"@included",$,{propertyIsArray:!0});continue}if(z==="@graph"&&!(g(_)||i(_)))throw new m('Invalid JSON-LD syntax; "@graph" value must not be an object or an array.',"jsonld.SyntaxError",{code:"invalid @graph value",value:_});if(z==="@value"){X=_,R&&w(j,1.1)?T["@value"]=_:k(T,"@value",_,{propertyIsArray:O.isFrame});continue}if(z==="@language"){if(_===null)continue;if(!A(_)&&!O.isFrame)throw new m('Invalid JSON-LD syntax; "@language" value must be a string.',"jsonld.SyntaxError",{code:"invalid language-tagged string",value:_});_=f(_).map($=>A($)?$.toLowerCase():$);for(const $ of _)A($)&&!$.match(L)&&O.eventHandler&&c({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:$}},options:O});k(T,"@language",_,{propertyIsArray:O.isFrame});continue}if(z==="@direction"){if(!A(_)&&!O.isFrame)throw new m('Invalid JSON-LD syntax; "@direction" value must be a string.',"jsonld.SyntaxError",{code:"invalid base direction",value:_});_=f(_);for(const $ of _)if(A($)&&$!=="ltr"&&$!=="rtl")throw new m('Invalid JSON-LD syntax; "@direction" must be "ltr" or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",value:_});k(T,"@direction",_,{propertyIsArray:O.isFrame});continue}if(z==="@index"){if(!A(_))throw new m('Invalid JSON-LD syntax; "@index" value must be a string.',"jsonld.SyntaxError",{code:"invalid @index value",value:_});k(T,"@index",_);continue}if(z==="@reverse"){if(!g(_))throw new m('Invalid JSON-LD syntax; "@reverse" value must be an object.',"jsonld.SyntaxError",{code:"invalid @reverse value",value:_});if(P=await S.expand({activeCtx:j,activeProperty:"@reverse",element:_,options:O}),"@reverse"in P)for(const K in P["@reverse"])k(T,K,P["@reverse"][K],{propertyIsArray:!0});let $=T["@reverse"]||null;for(const K in P){if(K==="@reverse")continue;$===null&&($=T["@reverse"]={}),k($,K,[],{propertyIsArray:!0});const Y=P[K];for(let C=0;C<Y.length;++C){const Z=Y[C];if(n(Z)||t(Z))throw new m('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',"jsonld.SyntaxError",{code:"invalid reverse property value",value:P});k($,K,Z,{propertyIsArray:!0})}}continue}if(z==="@nest"){V.push(I);continue}let U=j;const Q=D(j,I,"@context");r(Q)||(U=await l({activeCtx:j,localCtx:Q,propagate:!0,overrideProtected:!0,options:O}));const W=D(j,I,"@container")||[];if(W.includes("@language")&&g(_)){const $=D(U,I,"@direction");P=F(U,_,$,O)}else if(W.includes("@index")&&g(_)){const $=W.includes("@graph"),K=D(U,I,"@index")||"@index",Y=K!=="@index"&&x(j,K,{vocab:!0},O);P=await M({activeCtx:U,options:O,activeProperty:I,value:_,asGraph:$,indexKey:K,propertyIndex:Y})}else if(W.includes("@id")&&g(_)){const $=W.includes("@graph");P=await M({activeCtx:U,options:O,activeProperty:I,value:_,asGraph:$,indexKey:"@id"})}else if(W.includes("@type")&&g(_))P=await M({activeCtx:U.revertToPreviousContext(),options:O,activeProperty:I,value:_,asGraph:!1,indexKey:"@type"});else{const $=z==="@list";if($||z==="@set"){let K=p;$&&J==="@graph"&&(K=null),P=await S.expand({activeCtx:U,activeProperty:K,element:_,options:O,insideList:$})}else D(j,I,"@type")==="@json"?P={"@type":"@json","@value":_}:P=await S.expand({activeCtx:U,activeProperty:I,element:_,options:O,insideList:!1})}if(!(P===null&&z!=="@value")){if(z!=="@list"&&!t(P)&&W.includes("@list")&&(P={"@list":f(P)}),W.includes("@graph")&&!W.some($=>$==="@id"||$==="@index")){if(P=f(P),O.isFrame||(P=P.filter($=>{const K=Object.keys($).length;return d({value:$,count:K,options:O})!==null})),P.length===0)continue;P=P.map($=>({"@graph":f($)}))}if(U.mappings.has(I)&&U.mappings.get(I).reverse){const $=T["@reverse"]=T["@reverse"]||{};P=f(P);for(let K=0;K<P.length;++K){const Y=P[K];if(n(Y)||t(Y))throw new m('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',"jsonld.SyntaxError",{code:"invalid reverse property value",value:P});k($,z,Y,{propertyIsArray:!0})}continue}k(T,z,P,{propertyIsArray:!0})}}if("@value"in T&&!(T["@type"]==="@json"&&w(j,1.1))){if((g(X)||i(X))&&!O.isFrame)throw new m('Invalid JSON-LD syntax; "@value" value must not be an object or an array.',"jsonld.SyntaxError",{code:"invalid value object value",value:X})}for(const I of V){const _=i(o[I])?o[I]:[o[I]];for(const P of _){if(!g(P)||Object.keys(P).some(z=>x(j,z,{vocab:!0},O)==="@value"))throw new m("Invalid JSON-LD syntax; nested value must be a node object.","jsonld.SyntaxError",{code:"invalid @nest value",value:P});await E({activeCtx:j,activeProperty:p,expandedActiveProperty:J,element:P,expandedParent:T,options:O,insideList:q,typeScopedContext:G,typeKey:y})}}}function b({activeCtx:j,activeProperty:p,value:J,options:o}){if(J==null)return null;const T=x(j,p,{vocab:!0},o);if(T==="@id")return x(j,J,{base:!0},o);if(T==="@type")return x(j,J,{vocab:!0,base:!0},{...o,typeExpansion:!0});const O=D(j,p,"@type");if((O==="@id"||T==="@graph")&&A(J)){const y=x(j,J,{base:!0},o);return y===null&&J.match(H)&&o.eventHandler&&c({event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:"Reserved @id found.",details:{id:p}},options:o}),{"@id":y}}if(O==="@vocab"&&A(J))return{"@id":x(j,J,{vocab:!0,base:!0},o)};if(u(T))return J;const q={};if(O&&!["@id","@vocab","@none"].includes(O))q["@type"]=O;else if(A(J)){const y=D(j,p,"@language");y!==null&&(q["@language"]=y);const G=D(j,p,"@direction");G!==null&&(q["@direction"]=G)}return["boolean","number","string"].includes(typeof J)||(J=J.toString()),q["@value"]=J,q}function F(j,p,J,o){const T=[],O=Object.keys(p).sort();for(const q of O){const y=x(j,q,{vocab:!0},o);let G=p[q];i(G)||(G=[G]);for(const B of G){if(B===null)continue;if(!A(B))throw new m("Invalid JSON-LD syntax; language map values must be strings.","jsonld.SyntaxError",{code:"invalid language map value",languageMap:p});const V={"@value":B};y!=="@none"&&(q.match(L)||o.eventHandler&&c({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:q}},options:o}),V["@language"]=q.toLowerCase()),J&&(V["@direction"]=J),T.push(V)}}return T}async function M({activeCtx:j,options:p,activeProperty:J,value:o,asGraph:T,indexKey:O,propertyIndex:q}){const y=[],G=Object.keys(o).sort(),B=O==="@type";for(let V of G){if(B){const I=D(j,V,"@context");r(I)||(j=await l({activeCtx:j,localCtx:I,propagate:!1,options:p}))}let X=o[V];i(X)||(X=[X]),X=await S.expand({activeCtx:j,activeProperty:J,element:X,options:p,insideList:!1,insideIndex:!0});let R;q?V==="@none"?R="@none":R=b({activeCtx:j,activeProperty:O,value:V,options:p}):R=x(j,V,{vocab:!0},p),O==="@id"?V=x(j,V,{base:!0},p):B&&(V=R);for(let I of X){if(T&&!s(I)&&(I={"@graph":[I]}),O==="@type")R==="@none"||(I["@type"]?I["@type"]=[V].concat(I["@type"]):I["@type"]=[V]);else{if(n(I)&&!["@language","@type","@index"].includes(O))throw new m(`Invalid JSON-LD syntax; Attempt to add illegal key to value object: "${O}".`,"jsonld.SyntaxError",{code:"invalid value object",value:I});q?R!=="@none"&&k(I,q,R,{propertyIsArray:!0,prependValue:!0}):R!=="@none"&&!(O in I)&&(I[O]=V)}y.push(I)}}return y}return Pe}var Ge,Tt;function de(){if(Tt)return Ge;Tt=1;const{isKeyword:m}=ie(),i=re(),g=ee(),h=te(),A=ne(),r={};return Ge=r,r.createMergedNodeMap=(t,n)=>{n=n||{};const s=n.issuer||new h.IdentifierIssuer("_:b"),v={"@default":{}};return r.createNodeMap(t,v,"@default",s),r.mergeNodeMaps(v)},r.createNodeMap=(t,n,s,v,x,D)=>{if(g.isArray(t)){for(const N of t)r.createNodeMap(N,n,s,v,void 0,D);return}if(!g.isObject(t)){D&&D.push(t);return}if(i.isValue(t)){if("@type"in t){let N=t["@type"];N.indexOf("_:")===0&&(t["@type"]=N=v.getId(N))}D&&D.push(t);return}else if(D&&i.isList(t)){const N=[];r.createNodeMap(t["@list"],n,s,v,x,N),D.push({"@list":N});return}if("@type"in t){const N=t["@type"];for(const L of N)L.indexOf("_:")===0&&v.getId(L)}g.isUndefined(x)&&(x=i.isBlankNode(t)?v.getId(t["@id"]):t["@id"]),D&&D.push({"@id":x});const u=n[s],l=u[x]=u[x]||{};l["@id"]=x;const w=Object.keys(t).sort();for(let N of w){if(N==="@id")continue;if(N==="@reverse"){const H={"@id":x},k=t["@reverse"];for(const f in k){const e=k[f];for(const a of e){let c=a["@id"];i.isBlankNode(a)&&(c=v.getId(c)),r.createNodeMap(a,n,s,v,c),h.addValue(u[c],f,H,{propertyIsArray:!0,allowDuplicate:!1})}}continue}if(N==="@graph"){x in n||(n[x]={}),r.createNodeMap(t[N],n,x,v);continue}if(N==="@included"){r.createNodeMap(t[N],n,s,v);continue}if(N!=="@type"&&m(N)){if(N==="@index"&&N in l&&(t[N]!==l[N]||t[N]["@id"]!==l[N]["@id"]))throw new A("Invalid JSON-LD syntax; conflicting @index property detected.","jsonld.SyntaxError",{code:"conflicting indexes",subject:l});l[N]=t[N];continue}const L=t[N];if(N.indexOf("_:")===0&&(N=v.getId(N)),L.length===0){h.addValue(l,N,[],{propertyIsArray:!0});continue}for(let H of L)if(N==="@type"&&(H=H.indexOf("_:")===0?v.getId(H):H),i.isSubject(H)||i.isSubjectReference(H)){if("@id"in H&&!H["@id"])continue;const k=i.isBlankNode(H)?v.getId(H["@id"]):H["@id"];h.addValue(l,N,{"@id":k},{propertyIsArray:!0,allowDuplicate:!1}),r.createNodeMap(H,n,s,v,k)}else if(i.isValue(H))h.addValue(l,N,H,{propertyIsArray:!0,allowDuplicate:!1});else if(i.isList(H)){const k=[];r.createNodeMap(H["@list"],n,s,v,x,k),H={"@list":k},h.addValue(l,N,H,{propertyIsArray:!0,allowDuplicate:!1})}else r.createNodeMap(H,n,s,v,x),h.addValue(l,N,H,{propertyIsArray:!0,allowDuplicate:!1})}},r.mergeNodeMapGraphs=t=>{const n={};for(const s of Object.keys(t).sort())for(const v of Object.keys(t[s]).sort()){const x=t[s][v];v in n||(n[v]={"@id":v});const D=n[v];for(const u of Object.keys(x).sort())if(m(u)&&u!=="@type")D[u]=h.clone(x[u]);else for(const l of x[u])h.addValue(D,u,h.clone(l),{propertyIsArray:!0,allowDuplicate:!1})}return n},r.mergeNodeMaps=t=>{const n=t["@default"],s=Object.keys(t).sort();for(const v of s){if(v==="@default")continue;const x=t[v];let D=n[v];D?"@graph"in D||(D["@graph"]=[]):n[v]=D={"@id":v,"@graph":[]};const u=D["@graph"];for(const l of Object.keys(x).sort()){const w=x[l];i.isSubjectReference(w)||u.push(w)}}return n},Ge}var Ve,kt;function pn(){if(kt)return Ve;kt=1;const{isSubjectReference:m}=re(),{createMergedNodeMap:i}=de(),g={};return Ve=g,g.flatten=h=>{const A=i(h),r=[],t=Object.keys(A).sort();for(let n=0;n<t.length;++n){const s=A[t[n]];m(s)||r.push(s)}return r},Ve}var $e,Mt;function gn(){if(Mt)return $e;Mt=1;const m=ne(),i=re(),g=ee(),{REGEX_BCP47:h,addValue:A}=te(),{handleEvent:r}=se(),{RDF_LIST:t,RDF_FIRST:n,RDF_REST:s,RDF_NIL:v,RDF_TYPE:x,RDF_JSON_LITERAL:D,XSD_BOOLEAN:u,XSD_DOUBLE:l,XSD_INTEGER:w,XSD_STRING:N}=tt(),L={};$e=L,L.fromRDF=async(k,f)=>{const{useRdfType:e=!1,useNativeTypes:a=!1,rdfDirection:c=null}=f,S={},d={"@default":S},E={};if(c){if(c==="compound-literal")throw new m("Unsupported rdfDirection value.","jsonld.InvalidRdfDirection",{value:c});if(c!=="i18n-datatype")throw new m("Unknown rdfDirection value.","jsonld.InvalidRdfDirection",{value:c})}for(const M of k){const j=M.graph.termType==="DefaultGraph"?"@default":M.graph.value;j in d||(d[j]={}),j!=="@default"&&!(j in S)&&(S[j]={"@id":j});const p=d[j],J=M.subject.value,o=M.predicate.value,T=M.object;J in p||(p[J]={"@id":J});const O=p[J],q=T.termType.endsWith("Node");if(q&&!(T.value in p)&&(p[T.value]={"@id":T.value}),o===x&&!e&&q){A(O,"@type",T.value,{propertyIsArray:!0});continue}const y=H(T,a,c,f);if(A(O,o,y,{propertyIsArray:!0}),q)if(T.value===v){const G=p[T.value];"usages"in G||(G.usages=[]),G.usages.push({node:O,property:o,value:y})}else T.value in E?E[T.value]=!1:E[T.value]={node:O,property:o,value:y}}for(const M in d){const j=d[M];if(!(v in j))continue;const p=j[v];if(p.usages){for(let J of p.usages){let o=J.node,T=J.property,O=J.value;const q=[],y=[];let G=Object.keys(o).length;for(;T===s&&g.isObject(E[o["@id"]])&&g.isArray(o[n])&&o[n].length===1&&g.isArray(o[s])&&o[s].length===1&&(G===3||G===4&&g.isArray(o["@type"])&&o["@type"].length===1&&o["@type"][0]===t)&&(q.push(o[n][0]),y.push(o["@id"]),J=E[o["@id"]],o=J.node,T=J.property,O=J.value,G=Object.keys(o).length,!!i.isBlankNode(o)););delete O["@id"],O["@list"]=q.reverse();for(const B of y)delete j[B]}delete p.usages}}const b=[],F=Object.keys(S).sort();for(const M of F){const j=S[M];if(M in d){const p=j["@graph"]=[],J=d[M],o=Object.keys(J).sort();for(const T of o){const O=J[T];i.isSubjectReference(O)||p.push(O)}}i.isSubjectReference(j)||b.push(j)}return b};function H(k,f,e,a){if(k.termType.endsWith("Node"))return{"@id":k.value};const c={"@value":k.value};if(k.language)k.language.match(h)||a.eventHandler&&r({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:k.language}},options:a}),c["@language"]=k.language;else{let S=k.datatype.value;if(S||(S=N),S===D){S="@json";try{c["@value"]=JSON.parse(c["@value"])}catch(d){throw new m("JSON literal could not be parsed.","jsonld.InvalidJsonLiteral",{code:"invalid JSON literal",value:c["@value"],cause:d})}}if(f){if(S===u)c["@value"]==="true"?c["@value"]=!0:c["@value"]==="false"&&(c["@value"]=!1);else if(g.isNumeric(c["@value"]))if(S===w){const d=parseInt(c["@value"],10);d.toFixed(0)===c["@value"]&&(c["@value"]=d)}else S===l&&(c["@value"]=parseFloat(c["@value"]));[u,w,l,N].includes(S)||(c["@type"]=S)}else if(e==="i18n-datatype"&&S.startsWith("https://www.w3.org/ns/i18n#")){const[,d,E]=S.split(/[#_]/);d.length>0&&(c["@language"]=d,d.match(h)||a.eventHandler&&r({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:d}},options:a})),c["@direction"]=E}else S!==N&&(c["@type"]=S)}return c}return $e}var ze,qt;function yn(){return qt||(qt=1,ze=function m(i){return i===null||typeof i!="object"||i.toJSON!=null?JSON.stringify(i):Array.isArray(i)?"["+i.reduce((g,h,A)=>{const r=A===0?"":",",t=h===void 0||typeof h=="symbol"?null:h;return g+r+m(t)},"")+"]":"{"+Object.keys(i).sort().reduce((g,h,A)=>{if(i[h]===void 0||typeof i[h]=="symbol")return g;const r=g.length===0?"":",";return g+r+m(h)+":"+m(i[h])},"")+"}"}),ze}var Xe,Ft;function mn(){if(Ft)return Xe;Ft=1;const{createNodeMap:m}=de(),{isKeyword:i}=ie(),g=re(),h=yn(),A=ne(),r=ee(),t=te(),{handleEvent:n}=se(),{RDF_FIRST:s,RDF_REST:v,RDF_NIL:x,RDF_TYPE:D,RDF_JSON_LITERAL:u,RDF_LANGSTRING:l,XSD_BOOLEAN:w,XSD_DOUBLE:N,XSD_INTEGER:L,XSD_STRING:H}=tt(),{isAbsolute:k}=ae(),f={};Xe=f,f.toRDF=(S,d)=>{const E=new t.IdentifierIssuer("_:b"),b={"@default":{}};m(S,b,"@default",E);const F=[],M=Object.keys(b).sort();for(const j of M){let p;if(j==="@default")p={termType:"DefaultGraph",value:""};else if(k(j))j.startsWith("_:")?p={termType:"BlankNode"}:p={termType:"NamedNode"},p.value=j;else{d.eventHandler&&n({event:{type:["JsonLdEvent"],code:"relative graph reference",level:"warning",message:"Relative graph reference found.",details:{graph:j}},options:d});continue}e(F,b[j],p,E,d)}return F};function e(S,d,E,b,F){const M=Object.keys(d).sort();for(const j of M){const p=d[j],J=Object.keys(p).sort();for(let o of J){const T=p[o];if(o==="@type")o=D;else if(i(o))continue;for(const O of T){const q={termType:j.startsWith("_:")?"BlankNode":"NamedNode",value:j};if(!k(j)){F.eventHandler&&n({event:{type:["JsonLdEvent"],code:"relative subject reference",level:"warning",message:"Relative subject reference found.",details:{subject:j}},options:F});continue}const y={termType:o.startsWith("_:")?"BlankNode":"NamedNode",value:o};if(!k(o)){F.eventHandler&&n({event:{type:["JsonLdEvent"],code:"relative predicate reference",level:"warning",message:"Relative predicate reference found.",details:{predicate:o}},options:F});continue}if(y.termType==="BlankNode"&&!F.produceGeneralizedRdf){F.eventHandler&&n({event:{type:["JsonLdEvent"],code:"blank node predicate",level:"warning",message:"Dropping blank node predicate.",details:{property:b.getOldIds().find(B=>b.getId(B)===o)}},options:F});continue}const G=c(O,b,S,E,F.rdfDirection,F);G&&S.push({subject:q,predicate:y,object:G,graph:E})}}}}function a(S,d,E,b,F,M){const j={termType:"NamedNode",value:s},p={termType:"NamedNode",value:v},J={termType:"NamedNode",value:x},o=S.pop(),T=o?{termType:"BlankNode",value:d.getId()}:J;let O=T;for(const q of S){const y=c(q,d,E,b,F,M),G={termType:"BlankNode",value:d.getId()};E.push({subject:O,predicate:j,object:y,graph:b}),E.push({subject:O,predicate:p,object:G,graph:b}),O=G}if(o){const q=c(o,d,E,b,F,M);E.push({subject:O,predicate:j,object:q,graph:b}),E.push({subject:O,predicate:p,object:J,graph:b})}return T}function c(S,d,E,b,F,M){const j={};if(g.isValue(S)){j.termType="Literal",j.value=void 0,j.datatype={termType:"NamedNode"};let p=S["@value"];const J=S["@type"]||null;if(J==="@json")j.value=h(p),j.datatype.value=u;else if(r.isBoolean(p))j.value=p.toString(),j.datatype.value=J||w;else if(r.isDouble(p)||J===N)r.isDouble(p)||(p=parseFloat(p)),j.value=p.toExponential(15).replace(/(\d)0*e\+?/,"$1E"),j.datatype.value=J||N;else if(r.isNumber(p))j.value=p.toFixed(0),j.datatype.value=J||L;else if("@direction"in S&&F==="i18n-datatype"){const o=(S["@language"]||"").toLowerCase(),T=S["@direction"],O=`https://www.w3.org/ns/i18n#${o}_${T}`;j.datatype.value=O,j.value=p}else{if("@direction"in S&&F==="compound-literal")throw new A("Unsupported rdfDirection value.","jsonld.InvalidRdfDirection",{value:F});if("@direction"in S&&F)throw new A("Unknown rdfDirection value.","jsonld.InvalidRdfDirection",{value:F});"@language"in S?("@direction"in S&&!F&&M.eventHandler&&n({event:{type:["JsonLdEvent"],code:"rdfDirection not set",level:"warning",message:"rdfDirection not set for @direction.",details:{object:j.value}},options:M}),j.value=p,j.datatype.value=J||l,j.language=S["@language"]):("@direction"in S&&!F&&M.eventHandler&&n({event:{type:["JsonLdEvent"],code:"rdfDirection not set",level:"warning",message:"rdfDirection not set for @direction.",details:{object:j.value}},options:M}),j.value=p,j.datatype.value=J||H)}}else if(g.isList(S)){const p=a(S["@list"],d,E,b,F,M);j.termType=p.termType,j.value=p.value}else{const p=r.isObject(S)?S["@id"]:S;j.termType=p.startsWith("_:")?"BlankNode":"NamedNode",j.value=p}return j.termType==="NamedNode"&&!k(j.value)?(M.eventHandler&&n({event:{type:["JsonLdEvent"],code:"relative object reference",level:"warning",message:"Relative object reference found.",details:{object:j.value}},options:M}),null):j}return Xe}var Qe,Jt;function vn(){if(Jt)return Qe;Jt=1;const{isKeyword:m}=ie(),i=re(),g=ee(),h=te(),A=ae(),r=ne(),{createNodeMap:t,mergeNodeMapGraphs:n}=de(),s={};Qe=s,s.frameMergedOrDefault=(e,a,c)=>{const S={options:c,embedded:!1,graph:"@default",graphMap:{"@default":{}},subjectStack:[],link:{},bnodeMap:{}},d=new h.IdentifierIssuer("_:b");t(e,S.graphMap,"@default",d),c.merged&&(S.graphMap["@merged"]=n(S.graphMap),S.graph="@merged"),S.subjects=S.graphMap[S.graph];const E=[];s.frame(S,Object.keys(S.subjects).sort(),a,E),c.pruneBlankNodeIdentifiers&&(c.bnodesToClear=Object.keys(S.bnodeMap).filter(b=>S.bnodeMap[b].length===1));// remove @preserve from results
return c.link={},L(E,c)},s.frame=(e,a,c,S,d=null)=>{u(c),c=c[0];const E=e.options,b={embed:D(c,E,"embed"),explicit:D(c,E,"explicit"),requireAll:D(c,E,"requireAll")};e.link.hasOwnProperty(e.graph)||(e.link[e.graph]={});const F=e.link[e.graph],M=l(e,a,c,b),j=Object.keys(M).sort();for(const p of j){const J=M[p];if(d===null?e.uniqueEmbeds={[e.graph]:{}}:e.uniqueEmbeds[e.graph]=e.uniqueEmbeds[e.graph]||{},b.embed==="@link"&&p in F){H(S,d,F[p]);continue}const o={"@id":p};if(p.indexOf("_:")===0&&h.addValue(e.bnodeMap,p,o,{propertyIsArray:!0}),F[p]=o,(b.embed==="@first"||b.embed==="@last")&&e.is11)throw new r("Invalid JSON-LD syntax; invalid value of @embed.","jsonld.SyntaxError",{code:"invalid @embed value",frame:c});if(!(!e.embedded&&e.uniqueEmbeds[e.graph].hasOwnProperty(p))){if(e.embedded&&(b.embed==="@never"||x(J,e.graph,e.subjectStack))){H(S,d,o);continue}if(e.embedded&&(b.embed=="@first"||b.embed=="@once")&&e.uniqueEmbeds[e.graph].hasOwnProperty(p)){H(S,d,o);continue}if(b.embed==="@last"&&p in e.uniqueEmbeds[e.graph]&&N(e,p),e.uniqueEmbeds[e.graph][p]={parent:S,property:d},e.subjectStack.push({subject:J,graph:e.graph}),p in e.graphMap){let T=!1,O=null;"@graph"in c?(O=c["@graph"][0],T=!(p==="@merged"||p==="@default"),g.isObject(O)||(O={})):(T=e.graph!=="@merged",O={}),T&&s.frame({...e,graph:p,embedded:!1},Object.keys(e.graphMap[p]).sort(),[O],o,"@graph")}"@included"in c&&s.frame({...e,embedded:!1},a,c["@included"],o,"@included");for(const T of Object.keys(J).sort()){if(m(T)){if(o[T]=h.clone(J[T]),T==="@type")for(const O of J["@type"])O.indexOf("_:")===0&&h.addValue(e.bnodeMap,O,o,{propertyIsArray:!0});continue}if(!(b.explicit&&!(T in c)))for(const O of J[T]){const q=T in c?c[T]:v(b);if(i.isList(O)){const y=c[T]&&c[T][0]&&c[T][0]["@list"]?c[T][0]["@list"]:v(b),G={"@list":[]};H(o,T,G);const B=O["@list"];for(const V of B)i.isSubjectReference(V)?s.frame({...e,embedded:!0},[V["@id"]],y,G,"@list"):H(G,"@list",h.clone(V))}else i.isSubjectReference(O)?s.frame({...e,embedded:!0},[O["@id"]],q,o,T):f(q[0],O)&&H(o,T,h.clone(O))}}for(const T of Object.keys(c).sort()){if(T==="@type"){if(!g.isObject(c[T][0])||!("@default"in c[T][0]))continue}else if(m(T))continue;const O=c[T][0]||{};if(!D(O,E,"omitDefault")&&!(T in o)){let y="@null";"@default"in O&&(y=h.clone(O["@default"])),g.isArray(y)||(y=[y]),o[T]=[{"@preserve":y}]}}for(const T of Object.keys(c["@reverse"]||{}).sort()){const O=c["@reverse"][T];for(const q of Object.keys(e.subjects))h.getValues(e.subjects[q],T).some(G=>G["@id"]===p)&&(o["@reverse"]=o["@reverse"]||{},h.addValue(o["@reverse"],T,[],{propertyIsArray:!0}),s.frame({...e,embedded:!0},[q],O,o["@reverse"][T],d))}H(S,d,o),e.subjectStack.pop()}}},s.cleanupNull=(e,a)=>{if(g.isArray(e))return e.map(S=>s.cleanupNull(S,a)).filter(S=>S);if(e==="@null")return null;if(g.isObject(e)){if("@id"in e){const c=e["@id"];if(a.link.hasOwnProperty(c)){const S=a.link[c].indexOf(e);if(S!==-1)return a.link[c][S];a.link[c].push(e)}else a.link[c]=[e]}for(const c in e)e[c]=s.cleanupNull(e[c],a)}return e};function v(e){const a={};for(const c in e)e[c]!==void 0&&(a["@"+c]=[e[c]]);return[a]}function x(e,a,c){for(let S=c.length-1;S>=0;--S){const d=c[S];if(d.graph===a&&d.subject["@id"]===e["@id"])return!0}return!1}function D(e,a,c){const S="@"+c;let d=S in e?e[S][0]:a[c];if(c==="embed"){if(d===!0)d="@once";else if(d===!1)d="@never";else if(d!=="@always"&&d!=="@never"&&d!=="@link"&&d!=="@first"&&d!=="@last"&&d!=="@once")throw new r("Invalid JSON-LD syntax; invalid value of @embed.","jsonld.SyntaxError",{code:"invalid @embed value",frame:e})}return d}function u(e){if(!g.isArray(e)||e.length!==1||!g.isObject(e[0]))throw new r("Invalid JSON-LD syntax; a JSON-LD frame must be a single object.","jsonld.SyntaxError",{frame:e});if("@id"in e[0]){for(const a of h.asArray(e[0]["@id"]))if(!(g.isObject(a)||A.isAbsolute(a))||g.isString(a)&&a.indexOf("_:")===0)throw new r("Invalid JSON-LD syntax; invalid @id in frame.","jsonld.SyntaxError",{code:"invalid frame",frame:e})}if("@type"in e[0]){for(const a of h.asArray(e[0]["@type"]))if(!(g.isObject(a)||A.isAbsolute(a)||a==="@json")||g.isString(a)&&a.indexOf("_:")===0)throw new r("Invalid JSON-LD syntax; invalid @type in frame.","jsonld.SyntaxError",{code:"invalid frame",frame:e})}}function l(e,a,c,S){const d={};for(const E of a){const b=e.graphMap[e.graph][E];w(e,b,c,S)&&(d[E]=b)}return d}function w(e,a,c,S){let d=!0,E=!1;for(const b in c){let F=!1;const M=h.getValues(a,b),j=h.getValues(c,b).length===0;if(b==="@id"){if(g.isEmptyObject(c["@id"][0]||{})?F=!0:c["@id"].length>=0&&(F=c["@id"].includes(M[0])),!S.requireAll)return F}else if(b==="@type"){if(d=!1,j){if(M.length>0)return!1;F=!0}else if(c["@type"].length===1&&g.isEmptyObject(c["@type"][0]))F=M.length>0;else for(const p of c["@type"])g.isObject(p)&&"@default"in p?F=!0:F=F||M.some(J=>J===p);if(!S.requireAll)return F}else{if(m(b))continue;{const p=h.getValues(c,b)[0];let J=!1;if(p&&(u([p]),J="@default"in p),d=!1,M.length===0&&J)continue;if(M.length>0&&j)return!1;if(p===void 0){if(M.length>0)return!1;F=!0}else if(i.isList(p)){const o=p["@list"][0];if(i.isList(M[0])){const T=M[0]["@list"];i.isValue(o)?F=T.some(O=>f(o,O)):(i.isSubject(o)||i.isSubjectReference(o))&&(F=T.some(O=>k(e,o,O,S)))}}else i.isValue(p)?F=M.some(o=>f(p,o)):i.isSubjectReference(p)?F=M.some(o=>k(e,p,o,S)):g.isObject(p)?F=M.length>0:F=!1}}if(!F&&S.requireAll)return!1;E=E||F}return d||E}function N(e,a){const c=e.uniqueEmbeds[e.graph],S=c[a],d=S.parent,E=S.property,b={"@id":a};if(g.isArray(d)){for(let M=0;M<d.length;++M)if(h.compareValues(d[M],b)){d[M]=b;break}}else{const M=g.isArray(d[E]);h.removeValue(d,E,b,{propertyIsArray:M}),h.addValue(d,E,b,{propertyIsArray:M})}const F=M=>{const j=Object.keys(c);for(const p of j)p in c&&g.isObject(c[p].parent)&&c[p].parent["@id"]===M&&(delete c[p],F(p))};F(a)}/**
 * Removes the @preserve keywords from expanded result of framing.
 *
 * @param input the framed, framed output.
 * @param options the framing options used.
 *
 * @return the resulting output.
 */function L(e,a){if(g.isArray(e))return e.map(c=>L(c,a));if(g.isObject(e)){// remove @preserve
if("@preserve"in e)return e["@preserve"][0];if(i.isValue(e))return e;if(i.isList(e))return e["@list"]=L(e["@list"],a),e;if("@id"in e){const c=e["@id"];if(a.link.hasOwnProperty(c)){const S=a.link[c].indexOf(e);if(S!==-1)return a.link[c][S];a.link[c].push(e)}else a.link[c]=[e]}for(const c in e){if(c==="@id"&&a.bnodesToClear.includes(e[c])){delete e["@id"];continue}e[c]=L(e[c],a)}}return e}function H(e,a,c){g.isObject(e)?h.addValue(e,a,c,{propertyIsArray:!0}):e.push(c)}function k(e,a,c,S){if(!("@id"in c))return!1;const d=e.subjects[c["@id"]];return d&&w(e,d,a,S)}function f(e,a){const c=a["@value"],S=a["@type"],d=a["@language"],E=e["@value"]?g.isArray(e["@value"])?e["@value"]:[e["@value"]]:[],b=e["@type"]?g.isArray(e["@type"])?e["@type"]:[e["@type"]]:[],F=e["@language"]?g.isArray(e["@language"])?e["@language"]:[e["@language"]]:[];return E.length===0&&b.length===0&&F.length===0?!0:!(!(E.includes(c)||g.isEmptyObject(E[0]))||!(!S&&b.length===0||b.includes(S)||S&&g.isEmptyObject(b[0]))||!(!d&&F.length===0||F.includes(d)||d&&g.isEmptyObject(F[0])))}return Qe}var Ke,Ht;function bn(){if(Ht)return Ke;Ht=1;const m=ne(),{isArray:i,isObject:g,isString:h,isUndefined:A}=ee(),{isList:r,isValue:t,isGraph:n,isSimpleGraph:s,isSubjectReference:v}=re(),{expandIri:x,getContextValue:D,isKeyword:u,process:l,processingMode:w}=ie(),{removeBase:N,prependBase:L}=ae(),{REGEX_KEYWORD:H,addValue:k,asArray:f,compareShortestLeast:e}=te(),a={};Ke=a,a.compact=async({activeCtx:d,activeProperty:E=null,element:b,options:F={}})=>{if(i(b)){let j=[];for(let p=0;p<b.length;++p){const J=await a.compact({activeCtx:d,activeProperty:E,element:b[p],options:F});J!==null&&j.push(J)}return F.compactArrays&&j.length===1&&(D(d,E,"@container")||[]).length===0&&(j=j[0]),j}const M=D(d,E,"@context");if(A(M)||(d=await l({activeCtx:d,localCtx:M,propagate:!0,overrideProtected:!0,options:F})),g(b)){if(F.link&&"@id"in b&&F.link.hasOwnProperty(b["@id"])){const y=F.link[b["@id"]];for(let G=0;G<y.length;++G)if(y[G].expanded===b)return y[G].compacted}if(t(b)||v(b)){const y=a.compactValue({activeCtx:d,activeProperty:E,value:b,options:F});return F.link&&v(b)&&(F.link.hasOwnProperty(b["@id"])||(F.link[b["@id"]]=[]),F.link[b["@id"]].push({expanded:b,compacted:y})),y}if(r(b)&&(D(d,E,"@container")||[]).includes("@list"))return a.compact({activeCtx:d,activeProperty:E,element:b["@list"],options:F});const j=E==="@reverse",p={},J=d;!t(b)&&!v(b)&&(d=d.revertToPreviousContext());const o=D(J,E,"@context");A(o)||(d=await l({activeCtx:d,localCtx:o,propagate:!0,overrideProtected:!0,options:F})),F.link&&"@id"in b&&(F.link.hasOwnProperty(b["@id"])||(F.link[b["@id"]]=[]),F.link[b["@id"]].push({expanded:b,compacted:p}));let T=b["@type"]||[];T.length>1&&(T=Array.from(T).sort());const O=d;for(const y of T){const G=a.compactIri({activeCtx:O,iri:y,relativeTo:{vocab:!0}}),B=D(J,G,"@context");A(B)||(d=await l({activeCtx:d,localCtx:B,options:F,propagate:!1}))}const q=Object.keys(b).sort();for(const y of q){const G=b[y];if(y==="@id"){let B=f(G).map(X=>a.compactIri({activeCtx:d,iri:X,relativeTo:{vocab:!1},base:F.base}));B.length===1&&(B=B[0]);const V=a.compactIri({activeCtx:d,iri:"@id",relativeTo:{vocab:!0}});p[V]=B;continue}if(y==="@type"){let B=f(G).map(_=>a.compactIri({activeCtx:J,iri:_,relativeTo:{vocab:!0}}));B.length===1&&(B=B[0]);const V=a.compactIri({activeCtx:d,iri:"@type",relativeTo:{vocab:!0}}),I=(D(d,V,"@container")||[]).includes("@set")&&w(d,1.1)||i(B)&&G.length===0;k(p,V,B,{propertyIsArray:I});continue}if(y==="@reverse"){const B=await a.compact({activeCtx:d,activeProperty:"@reverse",element:G,options:F});for(const V in B)if(d.mappings.has(V)&&d.mappings.get(V).reverse){const X=B[V],I=(D(d,V,"@container")||[]).includes("@set")||!F.compactArrays;k(p,V,X,{propertyIsArray:I}),delete B[V]}if(Object.keys(B).length>0){const V=a.compactIri({activeCtx:d,iri:y,relativeTo:{vocab:!0}});k(p,V,B)}continue}if(y==="@preserve"){const B=await a.compact({activeCtx:d,activeProperty:E,element:G,options:F});i(B)&&B.length===0||k(p,y,B);continue}if(y==="@index"){if((D(d,E,"@container")||[]).includes("@index"))continue;const V=a.compactIri({activeCtx:d,iri:y,relativeTo:{vocab:!0}});k(p,V,G);continue}if(y!=="@graph"&&y!=="@list"&&y!=="@included"&&u(y)){const B=a.compactIri({activeCtx:d,iri:y,relativeTo:{vocab:!0}});k(p,B,G);continue}if(!i(G))throw new m("JSON-LD expansion error; expanded value must be an array.","jsonld.SyntaxError");if(G.length===0){const B=a.compactIri({activeCtx:d,iri:y,value:G,relativeTo:{vocab:!0},reverse:j}),V=d.mappings.has(B)?d.mappings.get(B)["@nest"]:null;let X=p;V&&(S(d,V,F),g(p[V])||(p[V]={}),X=p[V]),k(X,B,G,{propertyIsArray:!0})}for(const B of G){const V=a.compactIri({activeCtx:d,iri:y,value:B,relativeTo:{vocab:!0},reverse:j}),X=d.mappings.has(V)?d.mappings.get(V)["@nest"]:null;let R=p;X&&(S(d,X,F),g(p[X])||(p[X]={}),R=p[X]);const I=D(d,V,"@container")||[],_=n(B),P=r(B);let z;P?z=B["@list"]:_&&(z=B["@graph"]);let U=await a.compact({activeCtx:d,activeProperty:V,element:P||_?z:B,options:F});if(P)if(i(U)||(U=[U]),!I.includes("@list"))U={[a.compactIri({activeCtx:d,iri:"@list",relativeTo:{vocab:!0}})]:U},"@index"in B&&(U[a.compactIri({activeCtx:d,iri:"@index",relativeTo:{vocab:!0}})]=B["@index"]);else{k(R,V,U,{valueIsArray:!0,allowDuplicate:!0});continue}if(_)if(I.includes("@graph")&&(I.includes("@id")||I.includes("@index")&&s(B))){let Q;R.hasOwnProperty(V)?Q=R[V]:R[V]=Q={};const W=(I.includes("@id")?B["@id"]:B["@index"])||a.compactIri({activeCtx:d,iri:"@none",relativeTo:{vocab:!0}});k(Q,W,U,{propertyIsArray:!F.compactArrays||I.includes("@set")})}else I.includes("@graph")&&s(B)?(i(U)&&U.length>1&&(U={"@included":U}),k(R,V,U,{propertyIsArray:!F.compactArrays||I.includes("@set")})):(i(U)&&U.length===1&&F.compactArrays&&(U=U[0]),U={[a.compactIri({activeCtx:d,iri:"@graph",relativeTo:{vocab:!0}})]:U},"@id"in B&&(U[a.compactIri({activeCtx:d,iri:"@id",relativeTo:{vocab:!0}})]=B["@id"]),"@index"in B&&(U[a.compactIri({activeCtx:d,iri:"@index",relativeTo:{vocab:!0}})]=B["@index"]),k(R,V,U,{propertyIsArray:!F.compactArrays||I.includes("@set")}));else if(I.includes("@language")||I.includes("@index")||I.includes("@id")||I.includes("@type")){let Q;R.hasOwnProperty(V)?Q=R[V]:R[V]=Q={};let W;if(I.includes("@language"))t(U)&&(U=U["@value"]),W=B["@language"];else if(I.includes("@index")){const $=D(d,V,"@index")||"@index",K=a.compactIri({activeCtx:d,iri:$,relativeTo:{vocab:!0}});if($==="@index")W=B["@index"],delete U[K];else{let Y;if([W,...Y]=f(U[$]||[]),!h(W))W=null;else switch(Y.length){case 0:delete U[$];break;case 1:U[$]=Y[0];break;default:U[$]=Y;break}}}else if(I.includes("@id")){const $=a.compactIri({activeCtx:d,iri:"@id",relativeTo:{vocab:!0}});W=U[$],delete U[$]}else if(I.includes("@type")){const $=a.compactIri({activeCtx:d,iri:"@type",relativeTo:{vocab:!0}});let K;switch([W,...K]=f(U[$]||[]),K.length){case 0:delete U[$];break;case 1:U[$]=K[0];break;default:U[$]=K;break}Object.keys(U).length===1&&"@id"in B&&(U=await a.compact({activeCtx:d,activeProperty:V,element:{"@id":B["@id"]},options:F}))}W||(W=a.compactIri({activeCtx:d,iri:"@none",relativeTo:{vocab:!0}})),k(Q,W,U,{propertyIsArray:I.includes("@set")})}else{const Q=!F.compactArrays||I.includes("@set")||I.includes("@list")||i(U)&&U.length===0||y==="@list"||y==="@graph";k(R,V,U,{propertyIsArray:Q})}}}return p}return b},a.compactIri=({activeCtx:d,iri:E,value:b=null,relativeTo:F={vocab:!1},reverse:M=!1,base:j=null})=>{if(E===null)return E;d.isPropertyTermScoped&&d.previousContext&&(d=d.previousContext);const p=d.getInverse();if(u(E)&&E in p&&"@none"in p[E]&&"@type"in p[E]["@none"]&&"@none"in p[E]["@none"]["@type"])return p[E]["@none"]["@type"]["@none"];if(F.vocab&&E in p){const q=d["@language"]||"@none",y=[];g(b)&&"@index"in b&&!("@graph"in b)&&y.push("@index","@index@set"),g(b)&&"@preserve"in b&&(b=b["@preserve"][0]),n(b)?("@index"in b&&y.push("@graph@index","@graph@index@set","@index","@index@set"),"@id"in b&&y.push("@graph@id","@graph@id@set"),y.push("@graph","@graph@set","@set"),"@index"in b||y.push("@graph@index","@graph@index@set","@index","@index@set"),"@id"in b||y.push("@graph@id","@graph@id@set")):g(b)&&!t(b)&&y.push("@id","@id@set","@type","@set@type");let G="@language",B="@null";if(M)G="@type",B="@reverse",y.push("@set");else if(r(b)){"@index"in b||y.push("@list");const X=b["@list"];if(X.length===0)G="@any",B="@none";else{let R=X.length===0?q:null,I=null;for(let _=0;_<X.length;++_){const P=X[_];let z="@none",U="@none";if(t(P))if("@direction"in P){const Q=(P["@language"]||"").toLowerCase(),W=P["@direction"];z=`${Q}_${W}`}else"@language"in P?z=P["@language"].toLowerCase():"@type"in P?U=P["@type"]:z="@null";else U="@id";if(R===null?R=z:z!==R&&t(P)&&(R="@none"),I===null?I=U:U!==I&&(I="@none"),R==="@none"&&I==="@none")break}R=R||"@none",I=I||"@none",I!=="@none"?(G="@type",B=I):B=R}}else{if(t(b))if("@language"in b&&!("@index"in b)){y.push("@language","@language@set"),B=b["@language"];const X=b["@direction"];X&&(B=`${B}_${X}`)}else"@direction"in b&&!("@index"in b)?B=`_${b["@direction"]}`:"@type"in b&&(G="@type",B=b["@type"]);else G="@type",B="@id";y.push("@set")}y.push("@none"),g(b)&&!("@index"in b)&&y.push("@index","@index@set"),t(b)&&Object.keys(b).length===1&&y.push("@language","@language@set");const V=c(d,E,b,y,G,B);if(V!==null)return V}if(F.vocab&&"@vocab"in d){const q=d["@vocab"];if(E.indexOf(q)===0&&E!==q){const y=E.substr(q.length);if(!d.mappings.has(y))return y}}let J=null;const o=[];let T=d.fastCurieMap;const O=E.length-1;for(let q=0;q<O&&E[q]in T;++q)T=T[E[q]],""in T&&o.push(T[""][0]);for(let q=o.length-1;q>=0;--q){const y=o[q],G=y.terms;for(const B of G){const V=B+":"+E.substr(y.iri.length);d.mappings.get(B)._prefix&&(!d.mappings.has(V)||b===null&&d.mappings.get(V)["@id"]===E)&&(J===null||e(V,J)<0)&&(J=V)}}if(J!==null)return J;for(const[q,y]of d.mappings)if(y&&y._prefix&&E.startsWith(q+":"))throw new m(`Absolute IRI "${E}" confused with prefix "${q}".`,"jsonld.SyntaxError",{code:"IRI confused with prefix",context:d});if(!F.vocab)if("@base"in d)if(d["@base"]){const q=N(L(j,d["@base"]),E);return H.test(q)?`./${q}`:q}else return E;else return N(j,E);return E},a.compactValue=({activeCtx:d,activeProperty:E,value:b,options:F})=>{if(t(b)){const J=D(d,E,"@type"),o=D(d,E,"@language"),T=D(d,E,"@direction"),O=D(d,E,"@container")||[],q="@index"in b&&!O.includes("@index");if(!q&&J!=="@none"&&(b["@type"]===J||"@language"in b&&b["@language"]===o&&"@direction"in b&&b["@direction"]===T||"@language"in b&&b["@language"]===o||"@direction"in b&&b["@direction"]===T))return b["@value"];const y=Object.keys(b).length,G=y===1||y===2&&"@index"in b&&!q,B="@language"in d,V=h(b["@value"]),X=d.mappings.has(E)&&d.mappings.get(E)["@language"]===null;if(G&&J!=="@none"&&(!B||!V||X))return b["@value"];const R={};return q&&(R[a.compactIri({activeCtx:d,iri:"@index",relativeTo:{vocab:!0}})]=b["@index"]),"@type"in b?R[a.compactIri({activeCtx:d,iri:"@type",relativeTo:{vocab:!0}})]=a.compactIri({activeCtx:d,iri:b["@type"],relativeTo:{vocab:!0}}):"@language"in b&&(R[a.compactIri({activeCtx:d,iri:"@language",relativeTo:{vocab:!0}})]=b["@language"]),"@direction"in b&&(R[a.compactIri({activeCtx:d,iri:"@direction",relativeTo:{vocab:!0}})]=b["@direction"]),R[a.compactIri({activeCtx:d,iri:"@value",relativeTo:{vocab:!0}})]=b["@value"],R}const M=x(d,E,{vocab:!0},F),j=D(d,E,"@type"),p=a.compactIri({activeCtx:d,iri:b["@id"],relativeTo:{vocab:j==="@vocab"},base:F.base});return j==="@id"||j==="@vocab"||M==="@graph"?p:{[a.compactIri({activeCtx:d,iri:"@id",relativeTo:{vocab:!0}})]:p}};function c(d,E,b,F,M,j){j===null&&(j="@null");const p=[];if((j==="@id"||j==="@reverse")&&g(b)&&"@id"in b){j==="@reverse"&&p.push("@reverse");const o=a.compactIri({activeCtx:d,iri:b["@id"],relativeTo:{vocab:!0}});d.mappings.has(o)&&d.mappings.get(o)&&d.mappings.get(o)["@id"]===b["@id"]?p.push.apply(p,["@vocab","@id"]):p.push.apply(p,["@id","@vocab"])}else{p.push(j);const o=p.find(T=>T.includes("_"));o&&p.push(o.replace(/^[^_]+_/,"_"))}p.push("@none");const J=d.inverse[E];for(const o of F){if(!(o in J))continue;const T=J[o][M];for(const O of p)if(O in T)return T[O]}return null}function S(d,E,b){if(x(d,E,{vocab:!0},b)!=="@nest")throw new m("JSON-LD compact error; nested property must have an @nest value resolving to @nest.","jsonld.SyntaxError",{code:"invalid @nest value"})}return Ke}var We,Bt;function wn(){return Bt||(Bt=1,We=m=>{class i{toString(){return"[object JsonLdProcessor]"}}return Object.defineProperty(i,"prototype",{writable:!1,enumerable:!1}),Object.defineProperty(i.prototype,"constructor",{writable:!0,enumerable:!1,configurable:!0,value:i}),i.compact=function(g,h){return arguments.length<2?Promise.reject(new TypeError("Could not compact, too few arguments.")):m.compact(g,h)},i.expand=function(g){return arguments.length<1?Promise.reject(new TypeError("Could not expand, too few arguments.")):m.expand(g)},i.flatten=function(g){return arguments.length<1?Promise.reject(new TypeError("Could not flatten, too few arguments.")):m.flatten(g)},i}),We}/**
 * A JavaScript implementation of the JSON-LD API.
 *
 * @author Dave Longley
 *
 * @license BSD 3-Clause License
 * Copyright (c) 2011-2022 Digital Bazaar, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the Digital Bazaar, Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */var Ce,Ut;function In(){if(Ut)return Ce;Ut=1;const m=et(),i=on(),g=te(),h=dn(),A=g.IdentifierIssuer,r=ne(),t=Xt(),n=fn(),{expand:s}=hn(),{flatten:v}=pn(),{fromRDF:x}=gn(),{toRDF:D}=mn(),{frameMergedOrDefault:u,cleanupNull:l}=vn(),{isArray:w,isObject:N,isString:L}=ee(),{isSubjectReference:H}=re(),{expandIri:k,getInitialContext:f,process:e,processingMode:a}=ie(),{compact:c,compactIri:S}=bn(),{createNodeMap:d,createMergedNodeMap:E,mergeNodeMaps:b}=de(),{logEventHandler:F,logWarningEventHandler:M,safeEventHandler:j,setDefaultEventHandler:p,setupEventHandler:J,strictEventHandler:o,unhandledEventHandler:T}=se(),O=function(y){const G={},V=new t({max:100});y.compact=async function(R,I,_){if(arguments.length<2)throw new TypeError("Could not compact, too few arguments.");if(I===null)throw new r("The compaction context must not be null.","jsonld.CompactError",{code:"invalid local context"});if(R===null)return null;_=X(_,{base:L(R)?R:"",compactArrays:!0,compactToRelative:!0,graph:!1,skipExpansion:!1,link:!1,issuer:new A("_:b"),contextResolver:new h({sharedCache:V})}),_.link&&(_.skipExpansion=!0),_.compactToRelative||delete _.base;let P;_.skipExpansion?P=R:P=await y.expand(R,_);const z=await y.processContext(f(_),I,_);let U=await c({activeCtx:z,element:P,options:_});_.compactArrays&&!_.graph&&w(U)?U.length===1?U=U[0]:U.length===0&&(U={}):_.graph&&N(U)&&(U=[U]),N(I)&&"@context"in I&&(I=I["@context"]),I=g.clone(I),w(I)||(I=[I]);const Q=I;I=[];for(let $=0;$<Q.length;++$)(!N(Q[$])||Object.keys(Q[$]).length>0)&&I.push(Q[$]);const W=I.length>0;if(I.length===1&&(I=I[0]),w(U)){const $=S({activeCtx:z,iri:"@graph",relativeTo:{vocab:!0}}),K=U;U={},W&&(U["@context"]=I),U[$]=K}else if(N(U)&&W){const $=U;U={"@context":I};for(const K in $)U[K]=$[K]}return U},y.expand=async function(R,I){if(arguments.length<1)throw new TypeError("Could not expand, too few arguments.");I=X(I,{keepFreeFloatingNodes:!1,contextResolver:new h({sharedCache:V})});const _={},P=[];if("expandContext"in I){const W=g.clone(I.expandContext);N(W)&&"@context"in W?_.expandContext=W:_.expandContext={"@context":W},P.push(_.expandContext)}let z;if(!L(R))_.input=g.clone(R);else{const W=await y.get(R,I);z=W.documentUrl,_.input=W.document,W.contextUrl&&(_.remoteContext={"@context":W.contextUrl},P.push(_.remoteContext))}"base"in I||(I.base=z||"");let U=f(I);for(const W of P)U=await e({activeCtx:U,localCtx:W,options:I});let Q=await s({activeCtx:U,element:_.input,options:I});return N(Q)&&"@graph"in Q&&Object.keys(Q).length===1?Q=Q["@graph"]:Q===null&&(Q=[]),w(Q)||(Q=[Q]),Q},y.flatten=async function(R,I,_){if(arguments.length<1)return new TypeError("Could not flatten, too few arguments.");typeof I=="function"?I=null:I=I||null,_=X(_,{base:L(R)?R:"",contextResolver:new h({sharedCache:V})});const P=await y.expand(R,_),z=v(P);return I===null?z:(_.graph=!0,_.skipExpansion=!0,await y.compact(z,I,_))},y.frame=async function(R,I,_){if(arguments.length<2)throw new TypeError("Could not frame, too few arguments.");if(_=X(_,{base:L(R)?R:"",embed:"@once",explicit:!1,requireAll:!1,omitDefault:!1,bnodesToClear:[],contextResolver:new h({sharedCache:V})}),L(I)){const C=await y.get(I,_);if(I=C.document,C.contextUrl){let Z=I["@context"];Z?w(Z)?Z.push(C.contextUrl):Z=[Z,C.contextUrl]:Z=C.contextUrl,I["@context"]=Z}}const P=I?I["@context"]||{}:{},z=await y.processContext(f(_),P,_);_.hasOwnProperty("omitGraph")||(_.omitGraph=a(z,1.1)),_.hasOwnProperty("pruneBlankNodeIdentifiers")||(_.pruneBlankNodeIdentifiers=a(z,1.1));const U=await y.expand(R,_),Q={..._};Q.isFrame=!0,Q.keepFreeFloatingNodes=!0;const W=await y.expand(I,Q),$=Object.keys(I).map(C=>k(z,C,{vocab:!0}));Q.merged=!$.includes("@graph"),Q.is11=a(z,1.1);const K=u(U,W,Q);Q.graph=!_.omitGraph,Q.skipExpansion=!0,Q.link={},Q.framing=!0;let Y=await y.compact(K,P,Q);return Q.link={},Y=l(Y,Q),Y},y.link=async function(R,I,_){const P={};return I&&(P["@context"]=I),P["@embed"]="@link",y.frame(R,P,_)},y.normalize=y.canonize=async function(R,I){if(arguments.length<1)throw new TypeError("Could not canonize, too few arguments.");if(I=X(I,{base:L(R)?R:null,algorithm:"URDNA2015",skipExpansion:!1,safe:!0,contextResolver:new h({sharedCache:V})}),"inputFormat"in I){if(I.inputFormat!=="application/n-quads"&&I.inputFormat!=="application/nquads")throw new r("Unknown canonicalization input format.","jsonld.CanonizeError");const z=n.parse(R);return m.canonize(z,I)}const _={...I};delete _.format,_.produceGeneralizedRdf=!1;const P=await y.toRDF(R,_);return m.canonize(P,I)},y.fromRDF=async function(R,I){if(arguments.length<1)throw new TypeError("Could not convert from RDF, too few arguments.");I=X(I,{format:L(R)?"application/n-quads":void 0});const{format:_}=I;let{rdfParser:P}=I;if(_){if(P=P||G[_],!P)throw new r("Unknown input format.","jsonld.UnknownFormat",{format:_})}else P=()=>R;const z=await P(R);return x(z,I)},y.toRDF=async function(R,I){if(arguments.length<1)throw new TypeError("Could not convert to RDF, too few arguments.");I=X(I,{base:L(R)?R:"",skipExpansion:!1,contextResolver:new h({sharedCache:V})});let _;I.skipExpansion?_=R:_=await y.expand(R,I);const P=D(_,I);if(I.format){if(I.format==="application/n-quads"||I.format==="application/nquads")return n.serialize(P);throw new r("Unknown output format.","jsonld.UnknownFormat",{format:I.format})}return P},y.createNodeMap=async function(R,I){if(arguments.length<1)throw new TypeError("Could not create node map, too few arguments.");I=X(I,{base:L(R)?R:"",contextResolver:new h({sharedCache:V})});const _=await y.expand(R,I);return E(_,I)},y.merge=async function(R,I,_){if(arguments.length<1)throw new TypeError("Could not merge, too few arguments.");if(!w(R))throw new TypeError('Could not merge, "docs" must be an array.');typeof I=="function"?I=null:I=I||null,_=X(_,{contextResolver:new h({sharedCache:V})});const P=await Promise.all(R.map(C=>{const Z={..._};return y.expand(C,Z)}));let z=!0;"mergeNodes"in _&&(z=_.mergeNodes);const U=_.issuer||new A("_:b"),Q={"@default":{}};for(let C=0;C<P.length;++C){const Z=g.relabelBlankNodes(P[C],{issuer:new A("_:b"+C+"-")}),oe=z||C===0?Q:{"@default":{}};if(d(Z,oe,"@default",U),oe!==Q)for(const le in oe){const fe=oe[le];if(!(le in Q)){Q[le]=fe;continue}const nt=Q[le];for(const he in fe)he in nt||(nt[he]=fe[he])}}const W=b(Q),$=[],K=Object.keys(W).sort();for(let C=0;C<K.length;++C){const Z=W[K[C]];H(Z)||$.push(Z)}return I===null?$:(_.graph=!0,_.skipExpansion=!0,await y.compact($,I,_))},Object.defineProperty(y,"documentLoader",{get:()=>y._documentLoader,set:R=>y._documentLoader=R}),y.documentLoader=async R=>{throw new r("Could not retrieve a JSON-LD document from the URL. URL dereferencing not implemented.","jsonld.LoadDocumentError",{code:"loading document failed",url:R})},y.get=async function(R,I){let _;typeof I.documentLoader=="function"?_=I.documentLoader:_=y.documentLoader;const P=await _(R);try{if(!P.document)throw new r("No remote document found at the given URL.","jsonld.NullRemoteDocument");L(P.document)&&(P.document=JSON.parse(P.document))}catch(z){throw new r("Could not retrieve a JSON-LD document from the URL.","jsonld.LoadDocumentError",{code:"loading document failed",cause:z,remoteDoc:P})}return P},y.processContext=async function(R,I,_){return _=X(_,{base:"",contextResolver:new h({sharedCache:V})}),I===null?f(_):(I=g.clone(I),N(I)&&"@context"in I||(I={"@context":I}),e({activeCtx:R,localCtx:I,options:_}))},y.getContextValue=ie().getContextValue,y.documentLoaders={},y.useDocumentLoader=function(R){if(!(R in y.documentLoaders))throw new r('Unknown document loader type: "'+R+'"',"jsonld.UnknownDocumentLoader",{type:R});y.documentLoader=y.documentLoaders[R].apply(y,Array.prototype.slice.call(arguments,1))},y.registerRDFParser=function(R,I){G[R]=I},y.unregisterRDFParser=function(R){delete G[R]},y.registerRDFParser("application/n-quads",n.parse),y.registerRDFParser("application/nquads",n.parse),y.url=ae(),y.logEventHandler=F,y.logWarningEventHandler=M,y.safeEventHandler=j,y.setDefaultEventHandler=p,y.strictEventHandler=o,y.unhandledEventHandler=T,y.util=g,Object.assign(y,g),y.promises=y,y.RequestQueue=zt(),y.JsonLdProcessor=wn()(y),i.setupGlobals(y),i.setupDocumentLoaders(y);function X(R,{documentLoader:I=y.documentLoader,..._}){if(R&&"compactionMap"in R)throw new r('"compactionMap" not supported.',"jsonld.OptionsError");if(R&&"expansionMap"in R)throw new r('"expansionMap" not supported.',"jsonld.OptionsError");return Object.assign({},{documentLoader:I},_,R,{eventHandler:J({options:R})})}return y},q=function(){return O(function(){return q()})};return O(q),Ce=q,Ce}var xn=In();const En=Zt(xn),Nn=()=>{let m=null,i=0;function g(h,A){i++;const r=typeof h=="object"?h["@id"]||h["@value"]||`${h["@type"]}#${i}`:`${h}`;if(A.mergeNode(r,{x:Math.random(),y:Math.random(),size:10,label:r}),typeof h=="object"&&"@type"in h){for(const[t,n]of Object.entries(h))if(Array.isArray(n)){for(const s of n)if(s!==null){const v=g(s,A);A.addDirectedEdge(r,v,{type:"arrow",label:t})}}}return`${r}`}return fetch("./pina-colada.jsonld").then(async h=>{const A=await h.json(),r=new Qt({type:"directed",multi:!0}),t=await En.expand(A);for(const L of t)g(L,r);const n=document.getElementById("sigma-container"),s=document.getElementById("forceatlas2"),v=document.getElementById("forceatlas2-stop-label"),x=document.getElementById("forceatlas2-start-label"),D=Ct.inferSettings(r),u=new Yt(r,{settings:D});function l(){u.stop(),x.style.display="flex",v.style.display="none"}function w(){u.start(),x.style.display="none",v.style.display="flex"}function N(){u.isRunning()?l():w()}s.addEventListener("click",N),m=new Kt(r,n,{minCameraRatio:.08,maxCameraRatio:3,renderEdgeLabels:!0}),w()}),()=>{m==null||m.kill()}},jn=`<style>
  html,
  body,
  #storybook-root,
  #sigma-container {
    width: 100%;
    height: 100%;
    margin: 0 !important;
    padding: 0 !important;
    overflow: hidden;
  }
  #buttons {
    position: absolute;
    right: 1em;
    top: 1em;
    display: flex;
  }
  #buttons > button {
    margin-right: 1em;
    display: inline-block;
    text-align: center;
    background: white;
    outline: none;
    border: 1px solid dimgrey;
    border-radius: 2px;
    cursor: pointer;
  }
  #buttons > button img {
    height: 2em;
  }
  #buttons > button > span {
    height: 100%;
    display: flex;
    align-items: center;
  }
  #buttons > button:last-child {
    margin-right: 0;
  }
</style>
<div id="sigma-container"></div>
<div id="buttons">
  <button id="forceatlas2">
    <span>
      <img id="forceatlas2-start-label" src="./BiPlay.svg" />
      <img id="forceatlas2-stop-label" style="display: none" src="./BiPause.svg" />
      Force Atlas 2
    </span>
  </button>
</div>
`,Sn=`/**
 * This is a minimal example to show how to load a RDF graph file into graphology and display it.
 * The way the graph is created from JSON-LD can be adapted to your needs.
 */
import Graph from "graphology";
import forceAtlas2 from "graphology-layout-forceatlas2";
import FA2Layout from "graphology-layout-forceatlas2/worker";
import jsonld, { type NodeObject } from "jsonld";
import Sigma from "sigma";

export default () => {
  let renderer: Sigma | null = null;

  // Track the global ID to avoid merging nodes of the same type
  let GLOBAL_ID = 0;

  /**
   * Recursive function that parse the extended JSON-LD structure
   * and builds the graph.
   */
  function parseJsonLdExtended(item: NodeObject, graph: Graph): string {
    GLOBAL_ID++;
    // If we just have the type, we add a unique ID to avoid merge node of same type in one node
    const subjectId =
      typeof item === "object" ? item["@id"] || item["@value"] || \`\${item["@type"]}#\${GLOBAL_ID}\` : \`\${item}\`;
    graph.mergeNode(subjectId, { x: Math.random(), y: Math.random(), size: 10, label: subjectId });

    if (typeof item === "object" && "@type" in item) {
      // for each predicate, object , we build the edge (and the subgraph if needed by recursivity).
      for (const [predicate, objects] of Object.entries(item)) {
        if (Array.isArray(objects)) {
          for (const obj of objects) {
            if (obj !== null) {
              const objectId = parseJsonLdExtended(obj as NodeObject, graph);
              graph.addDirectedEdge(subjectId, objectId, {
                type: "arrow",
                label: predicate,
              });
            }
          }
        }
      }
    }
    return \`\${subjectId}\`;
  }

  fetch("./pina-colada.jsonld").then(async (res) => {
    const rdf = await res.json();
    const graph = new Graph({ type: "directed", multi: true });

    // Expand the JSON-LD to a full RDF graph
    const expanded = await jsonld.expand(rdf);
    for (const item of expanded) {
      parseJsonLdExtended(item, graph);
    }

    // Retrieve some useful DOM elements:
    const container = document.getElementById("sigma-container") as HTMLElement;
    const FA2Button = document.getElementById("forceatlas2") as HTMLElement;
    const FA2StopLabel = document.getElementById("forceatlas2-stop-label") as HTMLElement;
    const FA2StartLabel = document.getElementById("forceatlas2-start-label") as HTMLElement;

    /** FA2 LAYOUT **/
    /* This example shows how to use the force atlas 2 layout in a web worker */

    // Graphology provides a easy to use implementation of Force Atlas 2 in a web worker
    const sensibleSettings = forceAtlas2.inferSettings(graph);
    const fa2Layout = new FA2Layout(graph, {
      settings: sensibleSettings,
    });

    // This variable is used to toggle state between start and stop
    const cancelCurrentAnimation: (() => void) | null = null;

    // correlate start/stop actions with state management
    function stopFA2() {
      fa2Layout.stop();
      FA2StartLabel.style.display = "flex";
      FA2StopLabel.style.display = "none";
    }
    function startFA2() {
      if (cancelCurrentAnimation) cancelCurrentAnimation();
      fa2Layout.start();
      FA2StartLabel.style.display = "none";
      FA2StopLabel.style.display = "flex";
    }

    // the main toggle function
    function toggleFA2Layout() {
      if (fa2Layout.isRunning()) {
        stopFA2();
      } else {
        startFA2();
      }
    }
    // bind method to the forceatlas2 button
    FA2Button.addEventListener("click", toggleFA2Layout);

    // Instantiate sigma:
    renderer = new Sigma(graph, container, {
      minCameraRatio: 0.08,
      maxCameraRatio: 3,
      renderEdgeLabels: true,
    });

    // Strt FA2
    startFA2();
  });

  return () => {
    renderer?.kill();
  };
};
`,Gn={id:"load-rdf-file",title:"Core library/Advanced use cases"},Vn={name:"Load RDF file",render:()=>jn,play:Wt(Nn),args:{},parameters:{storySource:{source:Sn}}};export{Gn as default,Vn as story};
